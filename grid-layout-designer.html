<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="2607 é«˜åŸå…”">
    <meta name="copyright" content="Â© 2026 2607 é«˜åŸå…” ç‰ˆæƒæ‰€æœ‰">
    <title>ç®¡ç†åŠ©æ‰‹ | 2607 é«˜åŸå…”</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%2300d4ff'/><stop offset='100%25' style='stop-color:%230066cc'/></linearGradient></defs><circle cx='50' cy='50' r='45' fill='url(%23g)'/><ellipse cx='50' cy='50' rx='45' ry='18' fill='none' stroke='%23fff' stroke-width='2' opacity='0.6'/><ellipse cx='50' cy='50' rx='18' ry='45' fill='none' stroke='%23fff' stroke-width='2' opacity='0.6'/><path d='M10 35 Q50 25 90 35' fill='none' stroke='%234ecca3' stroke-width='3' opacity='0.8'/><path d='M10 65 Q50 75 90 65' fill='none' stroke='%234ecca3' stroke-width='3' opacity='0.8'/></svg>">
    <style>
        /* 
         * ============================================
         * ç®¡ç†åŠ©æ‰‹ - æ——å ¡å‘çŸ¿å¸ƒå±€å·¥å…·
         * Â© 2026 2607 é«˜åŸå…” ç‰ˆæƒæ‰€æœ‰
         * æœªç»æˆæƒç¦æ­¢å¤åˆ¶ã€ä¿®æ”¹æˆ–åˆ†å‘
         * ============================================
         */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        html, body { height: 100%; overflow: hidden; touch-action: none; }
        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: #1a1a2e;
            display: flex;
            color: #fff;
        }
        
        /* å“åº”å¼å¸ƒå±€ */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            .toolbar { 
                width: 100% !important; min-width: 100% !important; 
                flex-direction: row !important; flex-wrap: wrap;
                padding: 8px !important; gap: 6px !important;
                max-height: 180px; overflow-y: auto;
            }
            .toolbar h2 { display: none; }
            .tool-section, .alliance-section, .rotation-control { 
                flex: 1 1 auto; min-width: 120px; padding: 6px !important; 
            }
            .stats-panel, .action-btns, .shortcuts { display: none; }
            .rules-panel { display: none; }
            .main-area { flex: 1; }
            .header { padding: 4px 8px !important; }
            .header h1 { font-size: 12px !important; }
            .tool-btn { padding: 6px !important; font-size: 10px !important; }
            .alliance-btn { padding: 4px !important; font-size: 9px !important; }
        }
        
        .toolbar {
            width: 200px;
            min-width: 200px;
            background: rgba(0,0,0,0.3);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-right: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
        }
        .toolbar h2 { color: #00d4ff; font-size: 16px; text-align: center; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .tool-section { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; }
        .tool-section h3 { font-size: 11px; color: #888; margin-bottom: 6px; }
        .tool-btn {
            width: 100%; padding: 8px; margin-bottom: 4px;
            border: 2px solid transparent; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 12px;
            display: flex; align-items: center; gap: 6px;
            transition: all 0.2s;
        }
        .tool-btn:hover { transform: scale(1.02); }
        .tool-btn.active { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.3); }
        .tool-btn-qi { background: linear-gradient(135deg, #6495ED, #4169E1); color: #fff; }
        .tool-btn-bao { background: linear-gradient(135deg, #4ecca3, #2ed573); color: #fff; }
        .tool-btn-keng { background: linear-gradient(135deg, #ff6b6b, #ee5253); color: #fff; }
        .tool-btn-kuang { background: linear-gradient(135deg, #ffd93d, #f39c12); color: #333; }
        .tool-btn-delete { background: linear-gradient(135deg, #636e72, #2d3436); color: #fff; }
        .tool-btn-move { background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: #fff; }
        .tool-btn-pointer { background: linear-gradient(135deg, #fd79a8, #e84393); color: #fff; }
        .tool-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 11px; }
        
        /* è”ç›Ÿé€‰æ‹© */
        .alliance-section { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; }
        .alliance-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; }
        .alliance-btn {
            padding: 8px 4px; border: 2px solid transparent; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 10px;
            display: flex; flex-direction: column; align-items: center; gap: 2px;
            transition: all 0.2s;
        }
        .alliance-btn:hover { transform: scale(1.05); }
        .alliance-btn.active { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .alliance-color { width: 20px; height: 20px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3); }
        
        .rotation-control { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; }
        .rotation-control h3 { font-size: 11px; color: #888; margin-bottom: 6px; }
        .rotation-slider { width: 100%; margin: 6px 0; }
        .rotation-value { text-align: center; color: #00d4ff; font-weight: bold; font-size: 16px; }
        .rotation-presets { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 6px; }
        .rotation-preset { padding: 4px 8px; background: rgba(255,255,255,0.1); border: none; border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px; }
        .rotation-preset:hover { background: rgba(255,255,255,0.2); }
        .rotation-preset.active { background: #00d4ff; color: #000; }
        
        .stats-panel { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; }
        .stat-row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px; }
        .stat-label { color: #888; }
        .stat-value { color: #00d4ff; font-weight: bold; }
        .stat-value.success { color: #4ecca3; }
        .stat-value.warning { color: #ffd93d; }
        .stat-value.error { color: #ff6b6b; }
        
        .action-btns { display: flex; flex-direction: column; gap: 4px; }
        .action-btn { padding: 6px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }
        .btn-clear { background: #ff6b6b; color: #fff; }
        .btn-export { background: #4ecca3; color: #fff; }
        .btn-auto { background: #ffd93d; color: #333; }
        .btn-center { background: #a29bfe; color: #fff; }
        
        .shortcuts { font-size: 9px; color: #666; padding: 6px; background: rgba(255,255,255,0.03); border-radius: 4px; }
        .shortcuts kbd { background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 2px; }
        
        .main-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .header { padding: 8px 15px; background: rgba(0,0,0,0.2); display: flex; justify-content: space-between; align-items: center; }
        .header h1 { color: #00d4ff; font-size: 16px; }
        .header-info { display: flex; gap: 12px; font-size: 11px; color: #888; }
        .header-info span { background: rgba(255,255,255,0.1); padding: 3px 8px; border-radius: 4px; }
        .header-info .highlight { background: rgba(0, 212, 255, 0.2); color: #00d4ff; font-weight: bold; }
        
        .canvas-wrapper { flex: 1; overflow: hidden; background: #0a0a1f; position: relative; }
        canvas { display: block; cursor: crosshair; }
        
        .rules-panel {
            width: 220px; min-width: 220px;
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-left: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
        }
        .rules-panel h2 { color: #00d4ff; font-size: 14px; margin-bottom: 10px; }
        
        /* ç‰ˆæƒæ°´å° */
        .copyright-watermark {
            position: fixed; bottom: 10px; right: 10px;
            color: rgba(255,255,255,0.15); font-size: 11px;
            pointer-events: none; z-index: 9999;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .copyright-footer {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.8); color: #888;
            text-align: center; padding: 4px; font-size: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            z-index: 1000;
        }
        .copyright-footer a { color: #00d4ff; text-decoration: none; }
        @media (max-width: 768px) {
            .copyright-footer { font-size: 9px; padding: 3px; }
            .copyright-watermark { font-size: 9px; bottom: 25px; }
        }
        
        /* å¼¹çª—æ ·å¼ */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); z-index: 2000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: #1a1a2e; border-radius: 12px; padding: 20px;
            max-width: 500px; width: 90%; max-height: 80vh;
            border: 2px solid #00d4ff; box-shadow: 0 0 30px rgba(0,212,255,0.3);
        }
        .modal h3 { color: #00d4ff; margin-bottom: 15px; font-size: 16px; }
        .modal-tabs { display: flex; gap: 8px; margin-bottom: 15px; }
        .modal-tab {
            padding: 8px 16px; border: none; border-radius: 6px;
            background: rgba(255,255,255,0.1); color: #888; cursor: pointer;
            font-size: 12px;
        }
        .modal-tab.active { background: #00d4ff; color: #000; }
        .modal textarea {
            width: 100%; height: 150px; background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
            color: #fff; padding: 10px; font-size: 12px; resize: none;
            font-family: inherit;
        }
        .modal textarea:focus { outline: none; border-color: #00d4ff; }
        .modal-hint { color: #888; font-size: 10px; margin: 8px 0; }
        .modal-preview {
            max-height: 120px; overflow-y: auto; background: rgba(0,0,0,0.3);
            border-radius: 6px; padding: 8px; margin: 10px 0;
        }
        .modal-preview-item {
            display: flex; justify-content: space-between; padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 11px;
        }
        .modal-preview-item:last-child { border-bottom: none; }
        .modal-preview-num { color: #00d4ff; font-weight: bold; }
        .modal-preview-name { color: #fff; }
        .modal-btns { display: flex; gap: 10px; margin-top: 15px; }
        .modal-btn {
            flex: 1; padding: 10px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 12px;
        }
        .modal-btn-primary { background: #00d4ff; color: #000; }
        .modal-btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        
        /* ç™»å½•ç•Œé¢æ ·å¼ */
        .login-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a1f 100%);
            z-index: 9999; display: flex; justify-content: center; align-items: center;
        }
        .login-overlay.hidden { display: none; }
        .login-box {
            background: rgba(0,0,0,0.4); border-radius: 16px; padding: 40px;
            border: 2px solid rgba(0,212,255,0.3); box-shadow: 0 0 60px rgba(0,212,255,0.2);
            text-align: center; min-width: 320px;
        }
        .login-box h2 { color: #00d4ff; font-size: 24px; margin-bottom: 8px; }
        .login-box .subtitle { color: #888; font-size: 12px; margin-bottom: 30px; }
        .login-input {
            width: 100%; padding: 12px 16px; margin-bottom: 16px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px; color: #fff; font-size: 14px;
            transition: border-color 0.3s;
        }
        .login-input:focus { outline: none; border-color: #00d4ff; }
        .login-input::placeholder { color: #666; }
        .login-btn {
            width: 100%; padding: 14px; background: linear-gradient(135deg, #00d4ff, #0099cc);
            border: none; border-radius: 8px; color: #000; font-size: 14px;
            font-weight: bold; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
        }
        .login-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(0,212,255,0.4); }
        .login-btn:active { transform: translateY(0); }
        .login-error {
            color: #ff6b6b; font-size: 12px; margin-top: 12px;
            min-height: 18px; transition: opacity 0.3s;
        }
        .login-footer { color: #555; font-size: 10px; margin-top: 30px; }
        
        .rule-item { background: rgba(255,255,255,0.05); padding: 8px; border-radius: 6px; margin-bottom: 6px; border-left: 3px solid #4ecca3; }
        .rule-item.warning { border-left-color: #ffd93d; }
        .rule-item.info { border-left-color: #6495ED; }
        .rule-item h4 { color: #fff; font-size: 11px; margin-bottom: 3px; }
        .rule-item p { color: #888; font-size: 9px; line-height: 1.4; }
        
        .coord-info { background: rgba(0,212,255,0.1); padding: 8px; border-radius: 6px; margin-bottom: 8px; border: 1px solid rgba(0,212,255,0.3); }
        .coord-info h4 { color: #00d4ff; font-size: 11px; margin-bottom: 4px; }
        .coord-info p { color: #aaa; font-size: 9px; line-height: 1.5; }
        
        .building-info {
            position: fixed; background: rgba(0,0,0,0.95); color: #fff;
            padding: 10px 14px; border-radius: 8px; font-size: 11px;
            pointer-events: none; z-index: 1001; display: none;
            border: 2px solid #00d4ff; min-width: 140px;
        }
        .building-info-title { font-size: 13px; font-weight: bold; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .building-info-coord { color: #00d4ff; font-size: 18px; font-weight: bold; text-align: center; margin: 6px 0; }
        .building-info-note { color: #888; font-size: 9px; text-align: center; }
        .building-info-status { margin-top: 4px; padding-top: 4px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; }
        .building-info-status.active { color: #4ecca3; }
        .building-info-status.inactive { color: #636e72; }
        
        .tooltip {
            position: fixed; background: rgba(0,0,0,0.95); color: #fff;
            padding: 8px 12px; border-radius: 6px; font-size: 11px;
            pointer-events: none; z-index: 1000; display: none;
            border: 1px solid rgba(255,255,255,0.2); line-height: 1.5;
        }
        .tooltip.error { background: rgba(255,107,107,0.95); border-color: #ff6b6b; }
        .tooltip.success { background: rgba(30, 30, 60, 0.95); border-color: #4ecca3; }
        
        /* è¾¹ç•Œè­¦å‘Š */
        .boundary-warning {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 107, 107, 0.9); color: #fff;
            padding: 6px 12px; border-radius: 4px; font-size: 11px;
            display: none;
        }
    </style>
</head>
<body>
    <!-- ç™»å½•ç•Œé¢ -->
    <div class="login-overlay" id="login-overlay">
        <div class="login-box">
            <h2>ğŸŒ ç®¡ç†åŠ©æ‰‹</h2>
            <div class="subtitle">è¯·è¾“å…¥è´¦å·å¯†ç ç™»å½•</div>
            <input type="text" class="login-input" id="login-username" placeholder="ç”¨æˆ·å" autocomplete="off">
            <input type="password" class="login-input" id="login-password" placeholder="å¯†ç " autocomplete="off">
            <button class="login-btn" onclick="handleLogin()">ç™» å½•</button>
            <div class="login-error" id="login-error"></div>
            <div class="login-footer">Â© 2607 é«˜åŸå…” ç‰ˆæƒæ‰€æœ‰</div>
        </div>
    </div>
    
    <div class="toolbar">
        <h2>ğŸŒ ç®¡ç†åŠ©æ‰‹</h2>
        
        <div class="alliance-section">
            <h3>ğŸ´ é€‰æ‹©è”ç›Ÿ</h3>
            <div class="alliance-grid" id="alliance-grid">
                <!-- è”ç›ŸæŒ‰é’®ç”±JSç”Ÿæˆ -->
            </div>
        </div>
        
        <div class="tool-section">
            <h3>é€‰æ‹©å»ºç­‘</h3>
            <button class="tool-btn tool-btn-qi active" onclick="selectTool('qi')" id="tool-qi">
                <span class="tool-icon">ğŸš©</span><span>æ—— (7Ã—7)</span>
            </button>
            <button class="tool-btn tool-btn-bao" onclick="selectTool('bao')" id="tool-bao">
                <span class="tool-icon">ğŸ°</span><span>å ¡ (2Ã—2)</span>
            </button>
            <button class="tool-btn tool-btn-keng" onclick="selectTool('keng')" id="tool-keng">
                <span class="tool-icon">â­•</span><span>å‘ (3Ã—3)</span>
            </button>
            <button class="tool-btn tool-btn-kuang" onclick="selectTool('kuang')" id="tool-kuang">
                <span class="tool-icon">ğŸ’</span><span>çŸ¿ (2Ã—2)</span>
            </button>
        </div>
        
        <div class="tool-section">
            <h3>å·¥å…·</h3>
            <button class="tool-btn tool-btn-pointer" onclick="selectTool('pointer')" id="tool-pointer">
                <span class="tool-icon">ğŸ‘†</span><span>æŸ¥çœ‹åæ ‡</span>
            </button>
            <button class="tool-btn tool-btn-move" onclick="selectTool('move')" id="tool-move">
                <span class="tool-icon">âœ‹</span><span>ç§»åŠ¨ç”»å¸ƒ</span>
            </button>
            <button class="tool-btn tool-btn-delete" onclick="selectTool('delete')" id="tool-delete">
                <span class="tool-icon">ğŸ—‘ï¸</span><span>åˆ é™¤å»ºç­‘</span>
            </button>
        </div>
        
        <div class="rotation-control">
            <h3>ğŸ”„ ç”»å¸ƒæ—‹è½¬</h3>
            <div class="rotation-value"><span id="rotation-display">0</span>Â°</div>
            <input type="range" class="rotation-slider" id="rotation-slider" min="0" max="360" value="0" step="15" oninput="setRotation(this.value)">
            <div class="rotation-presets">
                <button class="rotation-preset active" onclick="setRotation(0)">0Â°</button>
                <button class="rotation-preset" onclick="setRotation(45)">45Â°</button>
                <button class="rotation-preset" onclick="setRotation(90)">90Â°</button>
                <button class="rotation-preset" onclick="setRotation(180)">180Â°</button>
            </div>
        </div>
        
        <div class="stats-panel">
            <h3>ç»Ÿè®¡</h3>
            <div id="alliance-stats">
                <!-- è”ç›Ÿç»Ÿè®¡ç”±JSç”Ÿæˆ -->
            </div>
            <div style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 6px; padding-top: 6px;">
                <div class="stat-row"><span class="stat-label">ğŸ° å ¡(ç”Ÿæ•ˆ)</span><span class="stat-value success" id="stat-bao-active">0</span></div>
                <div class="stat-row"><span class="stat-label">ğŸ° å ¡(æœªç”Ÿæ•ˆ)</span><span class="stat-value warning" id="stat-bao-inactive">0</span></div>
                <div class="stat-row"><span class="stat-label">â­• å‘</span><span class="stat-value" id="stat-keng">0</span></div>
                <div class="stat-row"><span class="stat-label">ğŸ’ çŸ¿</span><span class="stat-value" id="stat-kuang">0</span></div>
            </div>
        </div>
        
        <div class="action-btns">
            <button class="action-btn btn-center" onclick="centerView()">å›åˆ°ä¸­å¿ƒ</button>
            <button class="action-btn btn-auto" onclick="autoFillBao()">è‡ªåŠ¨å¡«å……å ¡</button>
            <button class="action-btn btn-auto" onclick="openNameMatcher()">ğŸ° åˆ†é…åç§°</button>
            <button class="action-btn btn-export" onclick="exportLayout()">ğŸ“¤ å¯¼å‡ºJSON</button>
            <button class="action-btn btn-export" onclick="importLayout()">ğŸ“¥ å¯¼å…¥JSON</button>
            <button class="action-btn btn-export" onclick="saveAsImage()">ğŸ–¼ï¸ ä¿å­˜å›¾ç‰‡</button>
            <button class="action-btn btn-clear" onclick="clearAll()">æ¸…ç©ºå…¨éƒ¨</button>
        </div>
        <input type="file" id="import-file" accept=".json" style="display:none" onchange="handleImport(event)">
        
        <div class="shortcuts">
            <div><kbd>1</kbd>æ—— <kbd>2</kbd>å ¡ <kbd>3</kbd>å‘ <kbd>4</kbd>çŸ¿</div>
            <div><kbd>P</kbd>æŸ¥çœ‹ <kbd>D</kbd>åˆ é™¤ <kbd>ç©ºæ ¼</kbd>ç§»åŠ¨</div>
            <div><kbd>Q</kbd>/<kbd>E</kbd>åˆ‡æ¢è”ç›Ÿ <kbd>C</kbd>å›ä¸­å¿ƒ</div>
        </div>
    </div>
    
    <div class="main-area">
        <div class="header">
            <h1>ğŸ¯ æ——å ¡å‘çŸ¿</h1>
            <div class="header-info">
                <span class="highlight">åæ ‡: <span id="mouse-game">(600, 600)</span></span>
                <span>ç¼©æ”¾: <span id="zoom-level">100%</span></span>
                <span id="boundary-status"></span>
            </div>
        </div>
        <div class="canvas-wrapper" id="canvas-wrapper">
            <canvas id="canvas"></canvas>
            <div class="boundary-warning" id="boundary-warning">âš  è¶…å‡ºåœ°å›¾è¾¹ç•Œ</div>
        </div>
    </div>
    
    <div class="rules-panel">
        <h2>ğŸ“‹ è§„åˆ™</h2>
        
        <div class="coord-info">
            <h4>ğŸ“ åæ ‡ç³»ç»Ÿ</h4>
            <p>â€¢ å³ä¸‹è§’: <strong>(0, 0)</strong><br>
               â€¢ å·¦ä¸Šè§’: <strong>(1199, 1199)</strong><br>
               â€¢ æ——/å‘: <strong>ä¸­å¿ƒåæ ‡</strong><br>
               â€¢ å ¡/çŸ¿: <strong>å³ä¸‹è§’åæ ‡</strong></p>
        </div>
        
        <div class="rule-item info"><h4>ğŸš© æ—— 7Ã—7</h4><p>6è”ç›Ÿä¸åŒè‰² | åŒç›Ÿç›¸è¿=æ¿€æ´»</p></div>
        <div class="rule-item"><h4>ğŸ° å ¡ 2Ã—2</h4><p>æ——å†…=ç»¿(ç”Ÿæ•ˆ) | æ——å¤–=ç°(ä¸ç”Ÿæ•ˆ)</p></div>
        <div class="rule-item warning"><h4>â­• å‘ 3Ã—3</h4><p>å¯æ”¾å¤šä¸ª | ä¸èƒ½é‡å </p></div>
        <div class="rule-item"><h4>ğŸ’ çŸ¿ 2Ã—2</h4><p>ä»»æ„ä½ç½®</p></div>
        
        <div class="rule-item warning">
            <h4>ğŸ’¡ æç¤º</h4>
            <p id="validation-msg">æ‚¬åœå»ºç­‘æŸ¥çœ‹åæ ‡</p>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    <div class="building-info" id="building-info">
        <div class="building-info-title" id="building-info-title">ğŸš© æ——</div>
        <div class="building-info-coord" id="building-info-coord">(100, 200)</div>
        <div class="building-info-note" id="building-info-note">ä¸­å¿ƒåæ ‡</div>
        <div class="building-info-status" id="building-info-status"></div>
    </div>
    
    <!-- ç‰ˆæƒä¿¡æ¯ -->
    <div class="copyright-watermark">Â© 2607 é«˜åŸå…”</div>
    <div class="copyright-footer">
        ğŸŒ ç®¡ç†åŠ©æ‰‹ v1.0 | Â© 2026 <strong>2607 é«˜åŸå…”</strong> ç‰ˆæƒæ‰€æœ‰ | æœªç»æˆæƒç¦æ­¢å¤åˆ¶åˆ†å‘
    </div>
    
    <!-- åç§°åˆ†é…å¼¹çª— -->
    <div class="modal-overlay" id="name-modal">
        <div class="modal">
            <h3>ğŸ° å ¡å’åç§°åˆ†é…</h3>
            <div class="modal-tabs">
                <button class="modal-tab active" onclick="switchModalTab(0)">çº¢ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(1)">è“ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(2)">ç»¿ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(3)">é»„ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(4)">ç´«ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(5)">æ©™ç›Ÿ</button>
            </div>
            <textarea id="name-input" placeholder="è¾“å…¥äººå‘˜åç§°ï¼Œæ¯è¡Œä¸€ä¸ªæˆ–ç”¨ç©ºæ ¼åˆ†éš”&#10;ä¾‹å¦‚ï¼š&#10;å¼ ä¸‰&#10;æå››&#10;ç‹äº”"></textarea>
            <div class="modal-hint">ğŸ’¡ åç§°å°†æŒ‰é¡ºåºåˆ†é…ç»™å½“å‰è”ç›Ÿçš„å ¡ï¼Œä»åºå·1å¼€å§‹</div>
            <div class="modal-preview" id="name-preview"></div>
            <div class="modal-btns">
                <button class="modal-btn modal-btn-secondary" onclick="closeNameMatcher()">å–æ¶ˆ</button>
                <button class="modal-btn modal-btn-secondary" onclick="clearBaoNames()">æ¸…é™¤åç§°</button>
                <button class="modal-btn modal-btn-primary" onclick="applyNames()">åº”ç”¨åˆ†é…</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * ============================================
         * ç®¡ç†åŠ©æ‰‹ - æ——å ¡å‘çŸ¿å¸ƒå±€å·¥å…·
         * Â© 2026 2607 é«˜åŸå…” ç‰ˆæƒæ‰€æœ‰
         * æœªç»æˆæƒç¦æ­¢å¤åˆ¶ã€ä¿®æ”¹æˆ–åˆ†å‘æœ¬ç¨‹åº
         * ============================================
         */
        
        // ç‰ˆæƒä¿æŠ¤æªæ–½
        (function() {
            // ç¦ç”¨å³é”®èœå•
            document.addEventListener('contextmenu', function(e) {
                if (e.target.tagName !== 'CANVAS') e.preventDefault();
            });
            // ç¦ç”¨F12å’ŒCtrl+Shift+I
            document.addEventListener('keydown', function(e) {
                if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
                    e.preventDefault();
                }
            });
            // æ§åˆ¶å°è­¦å‘Š
            console.log('%câš ï¸ ç‰ˆæƒå£°æ˜', 'color: #e74c3c; font-size: 20px; font-weight: bold;');
            console.log('%cæœ¬ç¨‹åºç”± 2607 é«˜åŸå…” å¼€å‘ï¼Œæœªç»æˆæƒç¦æ­¢å¤åˆ¶ã€ä¿®æ”¹æˆ–åˆ†å‘ã€‚', 'color: #f39c12; font-size: 14px;');
        })();
        
        // ========== ç™»å½•éªŒè¯ ==========
        const AUTH_USER = '2607';
        const AUTH_PASS = 'godm';
        
        function checkLogin() {
            return sessionStorage.getItem('loggedIn') === 'true';
        }
        
        function handleLogin() {
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            const errorEl = document.getElementById('login-error');
            
            if (username === AUTH_USER && password === AUTH_PASS) {
                sessionStorage.setItem('loggedIn', 'true');
                document.getElementById('login-overlay').classList.add('hidden');
                errorEl.textContent = '';
                initApp();
            } else {
                errorEl.textContent = 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯';
                document.getElementById('login-password').value = '';
            }
        }
        
        // å›è½¦é”®ç™»å½•
        document.addEventListener('DOMContentLoaded', function() {
            const usernameInput = document.getElementById('login-username');
            const passwordInput = document.getElementById('login-password');
            
            usernameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') passwordInput.focus();
            });
            passwordInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') handleLogin();
            });
            
            // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
            if (checkLogin()) {
                document.getElementById('login-overlay').classList.add('hidden');
                initApp();
            } else {
                usernameInput.focus();
            }
        });
        
        function initApp() {
            // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿DOMå®Œå…¨åŠ è½½
            setTimeout(init, 100);
        }
        
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const buildingInfo = document.getElementById('building-info');
        const boundaryWarning = document.getElementById('boundary-warning');
        
        // é…ç½®
        const CELL_SIZE = 10;
        const GAME_SIZE = 1200;
        const MAX_COORD = 1199;
        
        // è”ç›Ÿé…ç½®ï¼ˆ6ä¸ªè”ç›Ÿï¼‰
        const ALLIANCES = [
            { id: 0, name: 'çº¢ç›Ÿ', color: '#e74c3c', colorActive: 'rgba(231, 76, 60, 0.5)', colorInactive: 'rgba(231, 76, 60, 0.2)', borderActive: '#e74c3c', borderInactive: '#7a3d3d' },
            { id: 1, name: 'è“ç›Ÿ', color: '#3498db', colorActive: 'rgba(52, 152, 219, 0.5)', colorInactive: 'rgba(52, 152, 219, 0.2)', borderActive: '#3498db', borderInactive: '#2a5a7a' },
            { id: 2, name: 'ç»¿ç›Ÿ', color: '#2ecc71', colorActive: 'rgba(46, 204, 113, 0.5)', colorInactive: 'rgba(46, 204, 113, 0.2)', borderActive: '#2ecc71', borderInactive: '#1e7a46' },
            { id: 3, name: 'é»„ç›Ÿ', color: '#f1c40f', colorActive: 'rgba(241, 196, 15, 0.5)', colorInactive: 'rgba(241, 196, 15, 0.2)', borderActive: '#f1c40f', borderInactive: '#9a7d0a' },
            { id: 4, name: 'ç´«ç›Ÿ', color: '#9b59b6', colorActive: 'rgba(155, 89, 182, 0.5)', colorInactive: 'rgba(155, 89, 182, 0.2)', borderActive: '#9b59b6', borderInactive: '#5d3570' },
            { id: 5, name: 'æ©™ç›Ÿ', color: '#e67e22', colorActive: 'rgba(230, 126, 34, 0.5)', colorInactive: 'rgba(230, 126, 34, 0.2)', borderActive: '#e67e22', borderInactive: '#8a4c14' }
        ];
        
        const BUILDING_CONFIG = {
            qi:    { size: 7, name: 'æ——', icon: 'ğŸš©', coordType: 'center' },
            bao:   { size: 2, colorActive: '#4ecca3', colorInactive: '#636e72', border: '#2ed573', name: 'å ¡', icon: 'ğŸ°', coordType: 'bottomRight' },
            keng:  { size: 3, color: 'rgba(255, 107, 107, 0.6)', border: '#ee5253', name: 'å‘', icon: 'â­•', coordType: 'center' },
            kuang: { size: 2, color: '#ffd93d', border: '#f39c12', name: 'çŸ¿', icon: 'ğŸ’', coordType: 'bottomRight' }
        };
        
        // å½“å‰é€‰ä¸­çš„è”ç›Ÿ
        let currentAlliance = 0;
        
        // ç¼“å­˜æ¿€æ´»çš„æ——é›†åˆï¼ˆæŒ‰è”ç›Ÿåˆ†ç»„ï¼‰
        let activeQiSets = {};  // { allianceId: Set }
        
        // çŠ¶æ€
        let currentTool = 'qi';
        let buildings = { qi: [], bao: [], keng: [], kuang: [] };
        let panOffset = { x: 0, y: 0 };
        let zoom = 1;
        let rotation = 0;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let panStart = { x: 0, y: 0 };
        let previewPos = null;
        let hoveredBuilding = null;
        
        // ç¼“å­˜ï¼ˆæŒ‰è”ç›Ÿåˆ†ç»„ï¼‰
        let qiCoverageByAlliance = {};  // { allianceId: Set }
        let qiForbiddenCenters = new Set();
        let kengCoverage = new Set();
        
        // ========== åˆå§‹åŒ– ==========
        
        function init() {
            initAllianceUI();
            initAllianceStats();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            bindEvents();
            render();
        }
        
        function initAllianceUI() {
            const grid = document.getElementById('alliance-grid');
            grid.innerHTML = ALLIANCES.map((a, i) => `
                <button class="alliance-btn ${i === 0 ? 'active' : ''}" onclick="selectAlliance(${i})" id="alliance-${i}" style="background: ${a.colorInactive};">
                    <div class="alliance-color" style="background: ${a.color};"></div>
                    <span>${a.name}</span>
                </button>
            `).join('');
        }
        
        function initAllianceStats() {
            const container = document.getElementById('alliance-stats');
            container.innerHTML = ALLIANCES.map(a => `
                <div class="stat-row">
                    <span class="stat-label" style="color: ${a.color};">ğŸš© ${a.name}</span>
                    <span class="stat-value" id="stat-alliance-${a.id}">0/0</span>
                </div>
            `).join('');
        }
        
        function selectAlliance(id) {
            currentAlliance = id;
            document.querySelectorAll('.alliance-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === id);
            });
            // æ›´æ–°æ——æŒ‰é’®çš„é¢œè‰²æç¤º
            const qiBtn = document.getElementById('tool-qi');
            qiBtn.style.background = `linear-gradient(135deg, ${ALLIANCES[id].color}, ${ALLIANCES[id].borderInactive})`;
            render();
        }
        
        function resizeCanvas() {
            canvas.width = canvasWrapper.clientWidth;
            canvas.height = canvasWrapper.clientHeight;
            render();
        }
        
        function bindEvents() {
            // é¼ æ ‡äº‹ä»¶
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            
            // è§¦æ‘¸äº‹ä»¶æ”¯æŒï¼ˆæ‰‹æœºç«¯ï¼‰
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });
            canvas.addEventListener('wheel', onWheel, { passive: false });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }
        
        // ========== åæ ‡è½¬æ¢ ==========
        
        function screenToGame(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            
            // ç›¸å¯¹äºç”»å¸ƒä¸­å¿ƒ
            let relX = screenX - rect.left - canvas.width / 2;
            let relY = screenY - rect.top - canvas.height / 2;
            
            // é™¤ä»¥ç¼©æ”¾
            relX /= zoom;
            relY /= zoom;
            
            // åå‘æ—‹è½¬
            if (rotation !== 0) {
                const rad = -rotation * Math.PI / 180;
                const newX = relX * Math.cos(rad) - relY * Math.sin(rad);
                const newY = relX * Math.sin(rad) + relY * Math.cos(rad);
                relX = newX;
                relY = newY;
            }
            
            // å‡å»å¹³ç§»
            relX -= panOffset.x;
            relY -= panOffset.y;
            
            // è½¬æ¢ä¸ºæ¸¸æˆåæ ‡
            // ç”»å¸ƒä¸­å¿ƒ = æ¸¸æˆ(600, 600)
            // ç”»å¸ƒå³(+X) = æ¸¸æˆXå‡å°
            // ç”»å¸ƒä¸‹(+Y) = æ¸¸æˆYå‡å°
            const gameX = 600 - Math.floor(relX / CELL_SIZE);
            const gameY = 600 - Math.floor(relY / CELL_SIZE);
            
            return { x: gameX, y: gameY };
        }
        
        function gameToCanvas(gameX, gameY) {
            // æ¸¸æˆ(600,600) = ç”»å¸ƒä¸­å¿ƒ
            const canvasX = canvas.width / 2 + (600 - gameX) * CELL_SIZE + panOffset.x;
            const canvasY = canvas.height / 2 + (600 - gameY) * CELL_SIZE + panOffset.y;
            return { x: canvasX, y: canvasY };
        }
        
        function isInBounds(gameX, gameY) {
            return gameX >= 0 && gameX <= MAX_COORD && gameY >= 0 && gameY <= MAX_COORD;
        }
        
        function clampCoord(val) {
            return Math.max(0, Math.min(MAX_COORD, val));
        }
        
        function getBuildingDisplayCoord(type, gameX, gameY) {
            const config = BUILDING_CONFIG[type];
            const size = config.size;
            
            if (config.coordType === 'center') {
                return { x: gameX + Math.floor(size / 2), y: gameY + Math.floor(size / 2) };
            } else {
                return { x: gameX, y: gameY };
            }
        }
        
        // ========== é™åˆ¶å¹³ç§»èŒƒå›´ ==========
        
        function clampPanOffset() {
            // è®¡ç®—åœ°å›¾è¾¹ç•Œåœ¨ç”»å¸ƒä¸­çš„ä½ç½®
            // æ¸¸æˆ(0,0)åº”è¯¥åœ¨ç”»å¸ƒå³ä¸‹æ–¹å‘
            // æ¸¸æˆ(1199,1199)åº”è¯¥åœ¨ç”»å¸ƒå·¦ä¸Šæ–¹å‘
            
            // é™åˆ¶ä¸èƒ½æ‹–å‡ºå¤ªè¿œ
            const mapPixelSize = GAME_SIZE * CELL_SIZE; // 12000åƒç´ 
            const maxPan = mapPixelSize / 2; // 6000åƒç´ 
            
            panOffset.x = Math.max(-maxPan, Math.min(maxPan, panOffset.x));
            panOffset.y = Math.max(-maxPan, Math.min(maxPan, panOffset.y));
        }
        
        // ========== äº‹ä»¶å¤„ç† ==========
        
        function onMouseMove(e) {
            const gamePos = screenToGame(e.clientX, e.clientY);
            const inBounds = isInBounds(gamePos.x, gamePos.y);
            
            // æ˜¾ç¤ºåæ ‡ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼Œå³ä½¿è¶…å‡ºèŒƒå›´ï¼‰
            document.getElementById('mouse-game').textContent = `(${gamePos.x}, ${gamePos.y})`;
            
            // è¶…å‡ºè¾¹ç•Œè­¦å‘Š
            boundaryWarning.style.display = inBounds ? 'none' : 'block';
            
            // ç§»åŠ¨ç”»å¸ƒ
            if (currentTool === 'move' && isDragging) {
                const dx = (e.clientX - dragStart.x) / zoom;
                const dy = (e.clientY - dragStart.y) / zoom;
                panOffset.x = panStart.x + dx;
                panOffset.y = panStart.y + dy;
                clampPanOffset();
                render();
                return;
            }
            
            // å»ºç­‘æ”¾ç½®å·¥å…·
            if (['qi', 'bao', 'keng', 'kuang'].includes(currentTool)) {
                previewPos = alignToGrid(gamePos, currentTool);
                const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                const coord = getBuildingDisplayCoord(currentTool, previewPos.x, previewPos.y);
                const coordNote = BUILDING_CONFIG[currentTool].coordType === 'center' ? 'ä¸­å¿ƒ' : 'å³ä¸‹è§’';
                showTooltip(e.clientX, e.clientY, 
                    `${validation.message}\nåæ ‡(${coordNote}): (${coord.x}, ${coord.y})`, 
                    validation.valid);
                hideBuildingInfo();
                hoveredBuilding = null;
            } else {
                previewPos = null;
                // æŸ¥æ‰¾æ‚¬åœçš„å»ºç­‘ï¼ˆä»…åœ¨éæ”¾ç½®å·¥å…·æ—¶ï¼‰
                hoveredBuilding = findBuildingAt(gamePos.x, gamePos.y);
                
                if (hoveredBuilding) {
                    showBuildingInfo(e.clientX, e.clientY, hoveredBuilding);
                    hideTooltip();
                } else if (currentTool === 'pointer') {
                    hideBuildingInfo();
                    const status = inBounds ? 'æœ‰æ•ˆèŒƒå›´' : 'è¶…å‡ºè¾¹ç•Œ';
                    showTooltip(e.clientX, e.clientY, `åæ ‡: (${gamePos.x}, ${gamePos.y})\n${status}`, inBounds);
                } else {
                    hideBuildingInfo();
                    hideTooltip();
                }
            }
            
            render();
        }
        
        function findBuildingAt(gameX, gameY) {
            // æ£€æµ‹èŒƒå›´ç¨å¾®å®½æ¾ä¸€ç‚¹ï¼Œä½¿ç”¨ <= è€Œä¸æ˜¯ <
            for (const type of ['bao', 'kuang', 'keng', 'qi']) {
                const config = BUILDING_CONFIG[type];
                const size = config.size;
                for (const b of buildings[type]) {
                    // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨å»ºç­‘èŒƒå›´å†…ï¼ˆåŒ…å«è¾¹ç•Œï¼‰
                    if (gameX >= b.x && gameX <= b.x + size - 1 && gameY >= b.y && gameY <= b.y + size - 1) {
                        return { type, building: b };
                    }
                }
            }
            return null;
        }
        
        function showBuildingInfo(screenX, screenY, info) {
            const config = BUILDING_CONFIG[info.type];
            const coord = getBuildingDisplayCoord(info.type, info.building.x, info.building.y);
            const coordNote = config.coordType === 'center' ? 'ä¸­å¿ƒåæ ‡' : 'å³ä¸‹è§’åæ ‡';
            
            const statusEl = document.getElementById('building-info-status');
            let borderColor;
            
            if (info.type === 'qi') {
                const alliance = info.building.alliance;
                const allianceConfig = ALLIANCES[alliance];
                const qKey = `${info.building.x},${info.building.y}`;
                const isActive = activeQiSets[alliance] && activeQiSets[alliance].has(qKey);
                
                document.getElementById('building-info-title').innerHTML = `${config.icon} ${allianceConfig.name}`;
                statusEl.textContent = isActive ? 'âœ“ æ¿€æ´»' : 'âœ— æœªæ¿€æ´»';
                statusEl.className = 'building-info-status ' + (isActive ? 'active' : 'inactive');
                borderColor = isActive ? allianceConfig.borderActive : allianceConfig.borderInactive;
            } else {
                document.getElementById('building-info-title').innerHTML = `${config.icon} ${config.name}`;
                if (info.type === 'bao') {
                    const inQi = isBaoInQi(info.building.x, info.building.y);
                    statusEl.textContent = inQi ? 'âœ“ ç”Ÿæ•ˆä¸­' : 'âœ— æœªç”Ÿæ•ˆ';
                    statusEl.className = 'building-info-status ' + (inQi ? 'active' : 'inactive');
                } else {
                    statusEl.textContent = '';
                }
                borderColor = config.border;
            }
            
            document.getElementById('building-info-coord').textContent = `(${coord.x}, ${coord.y})`;
            document.getElementById('building-info-note').textContent = coordNote;
            
            buildingInfo.style.borderColor = borderColor;
            buildingInfo.style.left = (screenX + 15) + 'px';
            buildingInfo.style.top = (screenY - 10) + 'px';
            buildingInfo.style.display = 'block';
        }
        
        function hideBuildingInfo() { buildingInfo.style.display = 'none'; }
        
        function onMouseDown(e) {
            if (e.button === 2) {
                const gamePos = screenToGame(e.clientX, e.clientY);
                deleteAtPosition(gamePos.x, gamePos.y);
                return;
            }
            
            if (currentTool === 'move') {
                isDragging = true;
                dragStart = { x: e.clientX, y: e.clientY };
                panStart = { x: panOffset.x, y: panOffset.y };
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            if (currentTool === 'delete') {
                const gamePos = screenToGame(e.clientX, e.clientY);
                deleteAtPosition(gamePos.x, gamePos.y);
                return;
            }
            
            if (currentTool === 'pointer') return;
            
            if (['qi', 'bao', 'keng', 'kuang'].includes(currentTool) && previewPos) {
                const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                if (validation.valid) {
                    placeBuilding(currentTool, previewPos.x, previewPos.y);
                }
            }
        }
        
        function onMouseUp() {
            isDragging = false;
            if (currentTool === 'move') canvas.style.cursor = 'grab';
        }
        
        function onMouseLeave() {
            previewPos = null;
            hoveredBuilding = null;
            hideTooltip();
            hideBuildingInfo();
            boundaryWarning.style.display = 'none';
            render();
        }
        
        // ========== è§¦æ‘¸äº‹ä»¶ï¼ˆæ‰‹æœºç«¯ï¼‰==========
        
        let lastTouchDistance = 0;
        let touchStartTime = 0;
        
        function getTouchPos(e) {
            const touch = e.touches[0] || e.changedTouches[0];
            return { clientX: touch.clientX, clientY: touch.clientY };
        }
        
        function onTouchStart(e) {
            e.preventDefault();
            touchStartTime = Date.now();
            
            if (e.touches.length === 2) {
                // åŒæŒ‡ç¼©æ”¾
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.hypot(dx, dy);
                return;
            }
            
            const pos = getTouchPos(e);
            
            if (currentTool === 'move') {
                isDragging = true;
                dragStart = { x: pos.clientX, y: pos.clientY };
                panStart = { x: panOffset.x, y: panOffset.y };
            } else {
                // æ¨¡æ‹Ÿé¼ æ ‡ç§»åŠ¨æ¥æ›´æ–°é¢„è§ˆ
                onMouseMove({ clientX: pos.clientX, clientY: pos.clientY });
            }
        }
        
        function onTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 2) {
                // åŒæŒ‡ç¼©æ”¾
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.hypot(dx, dy);
                if (lastTouchDistance > 0) {
                    const scale = distance / lastTouchDistance;
                    zoom = Math.max(0.2, Math.min(3, zoom * scale));
                    document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
                    render();
                }
                lastTouchDistance = distance;
                return;
            }
            
            const pos = getTouchPos(e);
            
            if (currentTool === 'move' && isDragging) {
                const dx = (pos.clientX - dragStart.x) / zoom;
                const dy = (pos.clientY - dragStart.y) / zoom;
                panOffset.x = panStart.x + dx;
                panOffset.y = panStart.y + dy;
                clampPanOffset();
                render();
            } else {
                onMouseMove({ clientX: pos.clientX, clientY: pos.clientY });
            }
        }
        
        function onTouchEnd(e) {
            e.preventDefault();
            lastTouchDistance = 0;
            
            const touchDuration = Date.now() - touchStartTime;
            const pos = getTouchPos(e);
            
            if (currentTool === 'move') {
                isDragging = false;
            } else if (touchDuration < 300) {
                // çŸ­æŒ‰è§†ä¸ºç‚¹å‡»ï¼Œæ”¾ç½®å»ºç­‘
                onMouseMove({ clientX: pos.clientX, clientY: pos.clientY });
                if (['qi', 'bao', 'keng', 'kuang'].includes(currentTool) && previewPos) {
                    const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                    if (validation.valid) {
                        placeBuilding(currentTool, previewPos.x, previewPos.y);
                    }
                } else if (currentTool === 'delete') {
                    const gamePos = screenToGame(pos.clientX, pos.clientY);
                    deleteAtPosition(gamePos.x, gamePos.y);
                }
            }
            
            hideTooltip();
            render();
        }
        
        function onWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoom = Math.max(0.2, Math.min(3, zoom + delta));
            document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
            render();
        }
        
        function onKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case '1': selectTool('qi'); break;
                case '2': selectTool('bao'); break;
                case '3': selectTool('keng'); break;
                case '4': selectTool('kuang'); break;
                case 'p': selectTool('pointer'); break;
                case 'd': selectTool('delete'); break;
                case 'c': centerView(); break;
                case ' ': e.preventDefault(); selectTool('move'); break;
                case 'q': selectAlliance((currentAlliance - 1 + ALLIANCES.length) % ALLIANCES.length); break;
                case 'e': selectAlliance((currentAlliance + 1) % ALLIANCES.length); break;
            }
        }
        
        function onKeyUp(e) { if (e.key === ' ') selectTool('qi'); }
        
        // ========== æ§åˆ¶ ==========
        
        function centerView() {
            panOffset = { x: 0, y: 0 };
            render();
            showValidationMessage('å·²å›åˆ°ä¸­å¿ƒ (600, 600)');
        }
        
        function setRotation(deg) {
            rotation = parseInt(deg);
            document.getElementById('rotation-slider').value = rotation;
            document.getElementById('rotation-display').textContent = rotation;
            document.querySelectorAll('.rotation-preset').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.textContent) === rotation);
            });
            render();
        }
        
        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const toolBtn = document.getElementById('tool-' + tool);
            if (toolBtn) toolBtn.classList.add('active');
            canvas.style.cursor = tool === 'move' ? 'grab' : tool === 'delete' ? 'not-allowed' : tool === 'pointer' ? 'help' : 'crosshair';
        }
        
        function alignToGrid(pos, type) {
            const size = BUILDING_CONFIG[type].size;
            if (type === 'bao' || type === 'kuang') {
                // å¯¹é½åˆ°å¶æ•°åæ ‡ï¼Œä½¿ç”¨floorç¡®ä¿å¯¹é½æ›´ç¨³å®š
                return { x: Math.floor(pos.x / 2) * 2, y: Math.floor(pos.y / 2) * 2 };
            }
            // æ——å’Œå‘ï¼šä»¥ç‚¹å‡»ä½ç½®ä¸ºä¸­å¿ƒæ”¾ç½®
            return { x: pos.x - Math.floor(size / 2), y: pos.y - Math.floor(size / 2) };
        }
        
        // ========== éªŒè¯ ==========
        
        function validatePlacement(type, x, y) {
            const size = BUILDING_CONFIG[type].size;
            
            if (x < 0 || y < 0 || x + size > GAME_SIZE || y + size > GAME_SIZE) {
                return { valid: false, message: 'âŒ è¶…å‡ºåœ°å›¾èŒƒå›´(0-1199)' };
            }
            
            if (type === 'qi') {
                // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰æ——é‡å ï¼ˆå®Œå…¨ç›¸åŒä½ç½®ï¼‰
                for (const q of buildings.qi) {
                    if (q.x === x && q.y === y) return { valid: false, message: 'âŒ ä½ç½®å·²æœ‰æ——' };
                }
                // æ——å¯ä»¥éšæ„æ”¾ç½®ï¼Œä½†æ˜¾ç¤ºæ˜¯å¦æ¿€æ´»
                const allianceName = ALLIANCES[currentAlliance].name;
                const sameAllianceQi = getQiByAlliance(currentAlliance);
                const willBeActive = sameAllianceQi.length === 0 || isAdjacentToExistingQi(x, y, currentAlliance);
                return { valid: true, message: willBeActive ? `âœ“ ${allianceName}ï¼ˆæ¿€æ´»ï¼‰` : `âš  ${allianceName}ï¼ˆæœªæ¿€æ´»ï¼‰` };
            }
            
            if (type === 'bao') {
                for (let dx = 0; dx < size; dx++) {
                    for (let dy = 0; dy < size; dy++) {
                        const key = `${x + dx},${y + dy}`;
                        if (kengCoverage.has(key)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½å»ºåœ¨å‘ä¸Š' };
                        if (qiForbiddenCenters.has(key)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½è¦†ç›–æ——ä¸­å¿ƒ' };
                    }
                }
                for (const b of buildings.bao) { if (isOverlap(x, y, size, b.x, b.y, size)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½é‡å ' }; }
                for (const k of buildings.kuang) { if (isOverlap(x, y, size, k.x, k.y, 2)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½ä¸çŸ¿é‡å ' }; }
                return { valid: true, message: isBaoInQi(x, y) ? 'âœ“ å ¡ï¼ˆç”Ÿæ•ˆï¼‰' : 'âš  å ¡ï¼ˆä¸ç”Ÿæ•ˆï¼‰' };
            }
            
            if (type === 'keng') {
                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å‘é‡å 
                for (const k of buildings.keng) { if (isOverlap(x, y, size, k.x, k.y, 3)) return { valid: false, message: 'âŒ å‘ä¸èƒ½é‡å ' }; }
                // æ£€æŸ¥æ˜¯å¦ä¸å ¡/çŸ¿é‡å 
                for (let dx = 0; dx < size; dx++) {
                    for (let dy = 0; dy < size; dy++) {
                        for (const b of buildings.bao) { if (isOverlap(x + dx, y + dy, 1, b.x, b.y, 2)) return { valid: false, message: 'âŒ å‘ä¸èƒ½ä¸å ¡é‡å ' }; }
                        for (const k of buildings.kuang) { if (isOverlap(x + dx, y + dy, 1, k.x, k.y, 2)) return { valid: false, message: 'âŒ å‘ä¸èƒ½ä¸çŸ¿é‡å ' }; }
                    }
                }
                return { valid: true, message: 'âœ“ å¯ä»¥æ”¾ç½®å‘' };
            }
            
            if (type === 'kuang') {
                for (let dx = 0; dx < size; dx++) {
                    for (let dy = 0; dy < size; dy++) {
                        if (kengCoverage.has(`${x + dx},${y + dy}`)) return { valid: false, message: 'âŒ çŸ¿ä¸èƒ½å»ºåœ¨å‘ä¸Š' };
                    }
                }
                for (const k of buildings.kuang) { if (isOverlap(x, y, size, k.x, k.y, 2)) return { valid: false, message: 'âŒ çŸ¿ä¸èƒ½é‡å ' }; }
                for (const b of buildings.bao) { if (isOverlap(x, y, size, b.x, b.y, 2)) return { valid: false, message: 'âŒ çŸ¿ä¸èƒ½ä¸å ¡é‡å ' }; }
                return { valid: true, message: 'âœ“ å¯ä»¥æ”¾ç½®çŸ¿' };
            }
            
            return { valid: false, message: 'æœªçŸ¥é”™è¯¯' };
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸åŒè”ç›Ÿçš„ç°æœ‰æ——ç›¸é‚»
        function isAdjacentToExistingQi(x, y, alliance = currentAlliance) {
            for (const q of buildings.qi) {
                if (q.alliance === alliance && Math.abs(x - q.x) <= 7 && Math.abs(y - q.y) <= 7) return true;
            }
            return false;
        }
        
        // è·å–æŸè”ç›Ÿçš„æ——
        function getQiByAlliance(alliance) {
            return buildings.qi.filter(q => q.alliance === alliance);
        }
        
        // è·å–æŸè”ç›Ÿæ‰€æœ‰æ¿€æ´»çš„æ——ï¼ˆå½¢æˆè¿é€šåŒºåŸŸçš„æ——ï¼‰
        function getActiveQiSetForAlliance(alliance) {
            const allianceQi = getQiByAlliance(alliance);
            if (allianceQi.length === 0) return new Set();
            if (allianceQi.length === 1) return new Set([`${allianceQi[0].x},${allianceQi[0].y}`]);
            
            // æ‰¾åˆ°æœ€å¤§çš„è¿é€šåˆ†é‡
            const allQi = allianceQi.map(q => ({ x: q.x, y: q.y, key: `${q.x},${q.y}` }));
            const visited = new Set();
            let largestComponent = [];
            
            for (const start of allQi) {
                if (visited.has(start.key)) continue;
                
                const component = [];
                const queue = [start];
                visited.add(start.key);
                component.push(start.key);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    for (const other of allQi) {
                        if (!visited.has(other.key) && Math.abs(current.x - other.x) <= 7 && Math.abs(current.y - other.y) <= 7) {
                            visited.add(other.key);
                            queue.push(other);
                            component.push(other.key);
                        }
                    }
                }
                
                if (component.length > largestComponent.length) {
                    largestComponent = component;
                }
            }
            
            return new Set(largestComponent);
        }
        
        // æ›´æ–°æ‰€æœ‰è”ç›Ÿçš„æ¿€æ´»æ——é›†åˆ
        function updateActiveQiSets() {
            activeQiSets = {};
            for (const alliance of ALLIANCES) {
                activeQiSets[alliance.id] = getActiveQiSetForAlliance(alliance.id);
            }
        }
        
        // æ£€æŸ¥æ——æ˜¯å¦æ¿€æ´»
        function isQiActiveByKey(qKey, alliance) {
            return activeQiSets[alliance] && activeQiSets[alliance].has(qKey);
        }
        
        function isBaoInQi(bx, by) {
            // æ£€æŸ¥å ¡æ˜¯å¦åœ¨ä»»ä½•æ¿€æ´»æ——çš„è¦†ç›–èŒƒå›´å†…
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const key = `${bx + dx},${by + dy}`;
                    // æ£€æŸ¥æ‰€æœ‰è”ç›Ÿçš„è¦†ç›–èŒƒå›´
                    for (const allianceId in qiCoverageByAlliance) {
                        if (qiCoverageByAlliance[allianceId].has(key) && !qiForbiddenCenters.has(key)) return true;
                    }
                }
            }
            return false;
        }
        
        function isOverlap(x1, y1, s1, x2, y2, s2) {
            return x1 < x2 + s2 && x1 + s1 > x2 && y1 < y2 + s2 && y1 + s1 > y2;
        }
        
        // ========== æ“ä½œ ==========
        
        // è·å–æŸè”ç›Ÿå ¡çš„ä¸‹ä¸€ä¸ªåºå·
        function getNextBaoIndex(alliance) {
            const baosOfAlliance = buildings.bao.filter(b => b.alliance === alliance);
            return baosOfAlliance.length + 1;
        }
        
        // åˆ¤æ–­å ¡æ‰€å±çš„è”ç›Ÿï¼ˆé€šè¿‡å®ƒåœ¨å“ªä¸ªè”ç›Ÿçš„æ——è¦†ç›–èŒƒå›´å†…ï¼‰
        function getBaoAlliance(bx, by) {
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const key = `${bx + dx},${by + dy}`;
                    for (const allianceId in qiCoverageByAlliance) {
                        if (qiCoverageByAlliance[allianceId].has(key) && !qiForbiddenCenters.has(key)) {
                            return parseInt(allianceId);
                        }
                    }
                }
            }
            return null; // ä¸åœ¨ä»»ä½•æ——ä¸Š
        }
        
        function placeBuilding(type, x, y) {
            if (type === 'qi') {
                buildings[type].push({ x, y, alliance: currentAlliance });
            } else if (type === 'bao') {
                // å ¡æœ‰è”ç›Ÿå½’å±å’Œåºå·
                const alliance = getBaoAlliance(x, y);
                const index = alliance !== null ? getNextBaoIndex(alliance) : null;
                buildings[type].push({ x, y, alliance, index, name: '' });
            } else {
                buildings[type].push({ x, y });
            }
            updateCoverage();
            updateStats();
            render();
            const coord = getBuildingDisplayCoord(type, x, y);
            showValidationMessage(`${BUILDING_CONFIG[type].icon} â†’ (${coord.x}, ${coord.y})`);
        }
        
        function deleteAtPosition(gameX, gameY) {
            for (const type of ['bao', 'kuang', 'keng', 'qi']) {
                const size = BUILDING_CONFIG[type].size;
                for (let i = buildings[type].length - 1; i >= 0; i--) {
                    const b = buildings[type][i];
                    if (gameX >= b.x && gameX < b.x + size && gameY >= b.y && gameY < b.y + size) {
                        const coord = getBuildingDisplayCoord(type, b.x, b.y);
                        buildings[type].splice(i, 1);
                        updateCoverage(); updateStats(); render();
                        showValidationMessage(`åˆ é™¤ ${BUILDING_CONFIG[type].icon} (${coord.x}, ${coord.y})`);
                        return;
                    }
                }
            }
        }
        
        function updateCoverage() {
            qiCoverageByAlliance = {};
            qiForbiddenCenters = new Set();
            kengCoverage = new Set();
            
            // æ›´æ–°æ‰€æœ‰è”ç›Ÿçš„æ¿€æ´»æ——é›†åˆ
            updateActiveQiSets();
            
            // æŒ‰è”ç›Ÿè®¡ç®—è¦†ç›–èŒƒå›´ï¼ˆåªæœ‰æ¿€æ´»çš„æ——æ‰æä¾›è¦†ç›–ï¼‰
            for (const alliance of ALLIANCES) {
                qiCoverageByAlliance[alliance.id] = new Set();
            }
            
            for (const q of buildings.qi) {
                const qKey = `${q.x},${q.y}`;
                const alliance = q.alliance;
                if (activeQiSets[alliance] && activeQiSets[alliance].has(qKey)) {
                    for (let dx = 0; dx < 7; dx++) {
                        for (let dy = 0; dy < 7; dy++) {
                            qiCoverageByAlliance[alliance].add(`${q.x + dx},${q.y + dy}`);
                        }
                    }
                }
                qiForbiddenCenters.add(`${q.x + 3},${q.y + 3}`);
            }
            
            for (const k of buildings.keng) {
                for (let dx = 0; dx < 3; dx++) for (let dy = 0; dy < 3; dy++) kengCoverage.add(`${k.x + dx},${k.y + dy}`);
            }
        }
        
        function autoFillBao() {
            if (buildings.qi.length === 0) { showValidationMessage('è¯·å…ˆæ”¾ç½®æ——'); return; }
            let kengCenter = buildings.keng.length > 0 ? { x: buildings.keng[0].x + 1.5, y: buildings.keng[0].y + 1.5 } : { x: 600, y: 600 };
            const candidates = [], checked = new Set();
            // åˆå¹¶æ‰€æœ‰è”ç›Ÿçš„è¦†ç›–èŒƒå›´
            const allCoverage = new Set();
            for (const allianceId in qiCoverageByAlliance) {
                for (const key of qiCoverageByAlliance[allianceId]) {
                    allCoverage.add(key);
                }
            }
            for (const key of allCoverage) {
                const [ax, ay] = key.split(',').map(Number);
                const bx = Math.floor(ax / 2) * 2, by = Math.floor(ay / 2) * 2;
                for (let ox = -2; ox <= 2; ox += 2) {
                    for (let oy = -2; oy <= 2; oy += 2) {
                        const x = bx + ox, y = by + oy, posKey = `${x},${y}`;
                        if (!checked.has(posKey)) {
                            checked.add(posKey);
                            if (validatePlacement('bao', x, y).valid && isBaoInQi(x, y)) {
                                candidates.push({ x, y, dist: Math.hypot(x + 1 - kengCenter.x, y + 1 - kengCenter.y) });
                            }
                        }
                    }
                }
            }
            candidates.sort((a, b) => a.dist - b.dist);
            let placed = 0;
            for (const pos of candidates) {
                if (validatePlacement('bao', pos.x, pos.y).valid) { 
                    const alliance = getBaoAlliance(pos.x, pos.y);
                    const index = alliance !== null ? getNextBaoIndex(alliance) : null;
                    buildings.bao.push({ x: pos.x, y: pos.y, alliance, index, name: '' }); 
                    placed++; 
                }
            }
            updateCoverage(); updateStats(); render();
            showValidationMessage(`è‡ªåŠ¨å¡«å……äº† ${placed} ä¸ªå ¡`);
        }
        
        // ========== æ¸²æŸ“ ==========
        
        function render() {
            ctx.save();
            ctx.fillStyle = '#0f0f2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            drawGrid();
            drawBoundary();
            
            buildings.qi.forEach(b => drawBuilding('qi', b));
            buildings.keng.forEach(b => drawBuilding('keng', b));
            buildings.kuang.forEach(b => drawBuilding('kuang', b));
            buildings.bao.forEach(b => drawBuilding('bao', b));
            
            // ç»˜åˆ¶ç”»å¸ƒå†…æ°´å°
            drawCanvasWatermark();
            
            if (previewPos && ['qi', 'bao', 'keng', 'kuang'].includes(currentTool)) {
                const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                drawPreview(currentTool, previewPos.x, previewPos.y, validation.valid);
            }
            
            if (hoveredBuilding) drawBuildingHighlight(hoveredBuilding.type, hoveredBuilding.building.x, hoveredBuilding.building.y);
            
            ctx.restore();
        }
        
        function drawCanvasWatermark() {
            // åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶åŠé€æ˜æ°´å°
            ctx.save();
            ctx.globalAlpha = 0.08;
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // åœ¨å¤šä¸ªä½ç½®ç»˜åˆ¶æ°´å°
            const positions = [
                { x: canvas.width * 0.25, y: canvas.height * 0.3 },
                { x: canvas.width * 0.75, y: canvas.height * 0.3 },
                { x: canvas.width * 0.5, y: canvas.height * 0.6 },
                { x: canvas.width * 0.25, y: canvas.height * 0.8 },
                { x: canvas.width * 0.75, y: canvas.height * 0.8 }
            ];
            
            positions.forEach(pos => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(-15 * Math.PI / 180);
                ctx.fillText('2607 é«˜åŸå…”', 0, 0);
                ctx.restore();
            });
            
            ctx.restore();
        }
        
        function drawGrid() {
            const centerCanvasX = canvas.width / 2 + panOffset.x;
            const centerCanvasY = canvas.height / 2 + panOffset.y;
            
            // è®¡ç®—éœ€è¦ç»˜åˆ¶çš„ç½‘æ ¼èŒƒå›´ï¼ˆè¶³å¤Ÿå¤§ä»¥è¦†ç›–ç¼©æ”¾å’Œå¹³ç§»ï¼‰
            const viewSize = Math.max(canvas.width, canvas.height) / zoom;
            const gridRange = Math.ceil(viewSize / CELL_SIZE) + 50;
            
            // ç»˜åˆ¶ç½‘æ ¼
            for (let i = -gridRange; i <= gridRange; i++) {
                const x = centerCanvasX + i * CELL_SIZE;
                const y = centerCanvasY + i * CELL_SIZE;
                
                // æ¯10æ ¼åŠ ç²—
                if (i % 10 === 0) {
                    ctx.strokeStyle = '#4a4a7a';
                    ctx.lineWidth = 1;
                } else {
                    ctx.strokeStyle = '#2a2a5a';
                    ctx.lineWidth = 0.5;
                }
                
                ctx.beginPath();
                ctx.moveTo(x, centerCanvasY - gridRange * CELL_SIZE);
                ctx.lineTo(x, centerCanvasY + gridRange * CELL_SIZE);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerCanvasX - gridRange * CELL_SIZE, y);
                ctx.lineTo(centerCanvasX + gridRange * CELL_SIZE, y);
                ctx.stroke();
            }
            
            // ä¸­å¿ƒç‚¹æ ‡è®°
            ctx.fillStyle = 'rgba(0, 212, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(centerCanvasX, centerCanvasY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#00d4ff';
            ctx.textAlign = 'left';
            ctx.fillText('(600,600)', centerCanvasX + 12, centerCanvasY - 5);
        }
        
        function drawBoundary() {
            // ç»˜åˆ¶åœ°å›¾è¾¹ç•Œ (0-1199)
            const topLeft = gameToCanvas(1199, 1199);
            const bottomRight = gameToCanvas(0, 0);
            
            // å› ä¸ºæ¸¸æˆåæ ‡Yå‘ä¸Šå¢å¤§ï¼Œç”»å¸ƒYå‘ä¸‹å¢å¤§
            // topLeft åœ¨ç”»å¸ƒä¸Šæ–¹ï¼ŒbottomRight åœ¨ç”»å¸ƒä¸‹æ–¹
            const x = topLeft.x - GAME_SIZE * CELL_SIZE;
            const y = topLeft.y - GAME_SIZE * CELL_SIZE;
            const w = GAME_SIZE * CELL_SIZE;
            const h = GAME_SIZE * CELL_SIZE;
            
            // è¾¹ç•Œæ¡†
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(x, y, w, h);
            ctx.setLineDash([]);
            
            // å››è§’æ ‡ç­¾
            ctx.font = '11px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            
            // å·¦ä¸Šè§’ (1199, 1199)
            ctx.textAlign = 'left';
            ctx.fillText('(1199, 1199)', x + 5, y + 15);
            
            // å³ä¸‹è§’ (0, 0)
            ctx.textAlign = 'right';
            ctx.fillText('(0, 0)', x + w - 5, y + h - 5);
            
            // å³ä¸Šè§’ (0, 1199)
            ctx.textAlign = 'right';
            ctx.fillText('(0, 1199)', x + w - 5, y + 15);
            
            // å·¦ä¸‹è§’ (1199, 0)
            ctx.textAlign = 'left';
            ctx.fillText('(1199, 0)', x + 5, y + h - 5);
        }
        
        function drawBuilding(type, building) {
            const gameX = building.x;
            const gameY = building.y;
            const config = BUILDING_CONFIG[type];
            const size = config.size;
            const pos = gameToCanvas(gameX, gameY);
            const pSize = size * CELL_SIZE;
            const drawX = pos.x - pSize;
            const drawY = pos.y - pSize;
            
            // ç¡®å®šå¡«å……é¢œè‰²
            let fillColor, borderColor;
            if (type === 'qi') {
                const qKey = `${gameX},${gameY}`;
                const alliance = building.alliance;
                const allianceConfig = ALLIANCES[alliance];
                const isActive = activeQiSets[alliance] && activeQiSets[alliance].has(qKey);
                fillColor = isActive ? allianceConfig.colorActive : allianceConfig.colorInactive;
                borderColor = isActive ? allianceConfig.borderActive : allianceConfig.borderInactive;
            } else if (type === 'bao') {
                fillColor = isBaoInQi(gameX, gameY) ? config.colorActive : config.colorInactive;
                borderColor = config.border;
            } else {
                fillColor = config.color;
                borderColor = config.border;
            }
            
            ctx.fillStyle = fillColor;
            ctx.fillRect(drawX, drawY, pSize, pSize);
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = type === 'qi' ? 2 : 1;
            ctx.strokeRect(drawX + 0.5, drawY + 0.5, pSize - 1, pSize - 1);
            
            if (type === 'qi') {
                const centerPos = gameToCanvas(gameX + 3, gameY + 3);
                const cx = centerPos.x - CELL_SIZE, cy = centerPos.y - CELL_SIZE;
                ctx.fillStyle = '#0a0a1f';
                ctx.fillRect(cx, cy, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx + 2, cy + 2); ctx.lineTo(cx + CELL_SIZE - 2, cy + CELL_SIZE - 2);
                ctx.moveTo(cx + CELL_SIZE - 2, cy + 2); ctx.lineTo(cx + 2, cy + CELL_SIZE - 2);
                ctx.stroke();
            }
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (type === 'keng') { 
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#fff'; 
                ctx.fillText('å‘', drawX + pSize/2, drawY + pSize/2); 
            }
            if (type === 'kuang') { 
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#333'; 
                ctx.fillText('çŸ¿', drawX + pSize/2, drawY + pSize/2); 
            }
            if (type === 'bao') {
                // è·å–åæ ‡
                const coord = getBuildingDisplayCoord('bao', building.x, building.y);
                const hasIndex = building.index !== null && building.index !== undefined;
                const hasName = building.name && building.name.trim();
                
                // æ ¹æ®è”ç›Ÿè·å–é¢œè‰²
                const allianceColor = building.alliance !== null && building.alliance !== undefined 
                    ? ALLIANCES[building.alliance].borderActive 
                    : '#888';
                
                // å¤šè¡Œæ˜¾ç¤ºï¼šåºå·ã€åç§°ã€åæ ‡
                const centerX = drawX + pSize / 2;
                const lineHeight = pSize / 4; // æ¯è¡Œé«˜åº¦
                
                if (hasIndex || hasName) {
                    // ç¬¬ä¸€è¡Œï¼šåºå·
                    if (hasIndex) {
                        ctx.font = 'bold 8px Arial';
                        ctx.fillStyle = allianceColor;
                        ctx.fillText(building.index.toString(), centerX, drawY + lineHeight * 0.9);
                    }
                    
                    // ç¬¬äºŒè¡Œï¼šåç§°ï¼ˆæˆªæ–­æ˜¾ç¤ºï¼Œæœ€å¤š4å­—ç¬¦ï¼‰
                    if (hasName) {
                        let displayName = building.name;
                        if (displayName.length > 4) {
                            displayName = displayName.substring(0, 3) + 'â€¦';
                        }
                        ctx.font = 'bold 7px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.fillText(displayName, centerX, drawY + lineHeight * 2);
                    }
                    
                    // ç¬¬ä¸‰è¡Œï¼šåæ ‡
                    ctx.font = '5px Arial';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(`${coord.x},${coord.y}`, centerX, drawY + lineHeight * 3.1);
                } else {
                    // æ— åºå·æ—¶åªæ˜¾ç¤ºåæ ‡
                    ctx.font = '6px Arial';
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillText(`${coord.x},${coord.y}`, centerX, drawY + pSize / 2);
                }
            }
        }
        
        function drawBuildingHighlight(type, gameX, gameY) {
            const size = BUILDING_CONFIG[type].size;
            const pos = gameToCanvas(gameX, gameY);
            const pSize = size * CELL_SIZE;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            ctx.strokeRect(pos.x - pSize - 2, pos.y - pSize - 2, pSize + 4, pSize + 4);
            ctx.setLineDash([]);
        }
        
        function drawPreview(type, gameX, gameY, valid) {
            const size = BUILDING_CONFIG[type].size;
            const config = BUILDING_CONFIG[type];
            const pos = gameToCanvas(gameX, gameY);
            const pSize = size * CELL_SIZE;
            const drawX = pos.x - pSize, drawY = pos.y - pSize;
            
            // ç¡®å®šé¢„è§ˆé¢œè‰²
            let previewColor;
            if (!valid) {
                previewColor = 'rgba(255,0,0,0.4)';
            } else if (type === 'qi') {
                const allianceConfig = ALLIANCES[currentAlliance];
                const sameAllianceQi = getQiByAlliance(currentAlliance);
                const willBeActive = sameAllianceQi.length === 0 || isAdjacentToExistingQi(gameX, gameY, currentAlliance);
                previewColor = willBeActive ? allianceConfig.colorActive : allianceConfig.colorInactive;
            } else if (type === 'bao') {
                previewColor = isBaoInQi(gameX, gameY) ? config.colorActive : config.colorInactive;
            } else {
                previewColor = config.color || config.colorActive;
            }
            
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = previewColor;
            ctx.fillRect(drawX, drawY, pSize, pSize);
            ctx.strokeStyle = valid ? '#fff' : '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.strokeRect(drawX, drawY, pSize, pSize);
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
        }
        
        // ========== UI ==========
        
        function showTooltip(x, y, message, valid) {
            tooltip.innerHTML = message.replace(/\n/g, '<br>');
            tooltip.className = 'tooltip ' + (valid ? 'success' : 'error');
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() { tooltip.style.display = 'none'; }
        function showValidationMessage(msg) { document.getElementById('validation-msg').textContent = msg; }
        
        function updateStats() {
            // æŒ‰è”ç›Ÿç»Ÿè®¡æ——çš„æ•°é‡
            for (const alliance of ALLIANCES) {
                const allianceQi = getQiByAlliance(alliance.id);
                const activeCount = activeQiSets[alliance.id] ? activeQiSets[alliance.id].size : 0;
                const totalCount = allianceQi.length;
                const el = document.getElementById(`stat-alliance-${alliance.id}`);
                if (el) {
                    el.textContent = `${activeCount}/${totalCount}`;
                    el.className = 'stat-value ' + (activeCount === totalCount && totalCount > 0 ? 'success' : totalCount > 0 ? 'warning' : '');
                }
            }
            
            // ç»Ÿè®¡å‘å’ŒçŸ¿
            document.getElementById('stat-keng').textContent = buildings.keng.length;
            document.getElementById('stat-kuang').textContent = buildings.kuang.length;
            
            // ç»Ÿè®¡å ¡çš„ç”Ÿæ•ˆ/æœªç”Ÿæ•ˆæ•°é‡
            let baoActiveCount = 0, baoInactiveCount = 0;
            for (const b of buildings.bao) { 
                if (isBaoInQi(b.x, b.y)) baoActiveCount++; 
                else baoInactiveCount++; 
            }
            document.getElementById('stat-bao-active').textContent = baoActiveCount;
            document.getElementById('stat-bao-inactive').textContent = baoInactiveCount;
        }
        
        function clearAll() {
            if (confirm('ç¡®å®šæ¸…ç©ºï¼Ÿ')) {
                buildings = { qi: [], bao: [], keng: [], kuang: [] };
                updateCoverage(); updateStats(); render();
                showValidationMessage('å·²æ¸…ç©º');
            }
        }
        
        function exportLayout() {
            const exportData = { rotation, alliances: ALLIANCES.map(a => a.name), buildings: {} };
            for (const type of ['qi', 'bao', 'keng', 'kuang']) {
                exportData.buildings[type] = buildings[type].map(b => {
                    const coord = getBuildingDisplayCoord(type, b.x, b.y);
                    const data = { gameX: b.x, gameY: b.y, displayX: coord.x, displayY: coord.y };
                    if (type === 'qi') {
                        data.alliance = b.alliance;
                        data.allianceName = ALLIANCES[b.alliance].name;
                    }
                    if (type === 'bao') {
                        data.alliance = b.alliance;
                        data.index = b.index;
                        data.name = b.name || '';
                    }
                    return data;
                });
            }
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'layout-' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
            showValidationMessage('å·²å¯¼å‡º');
        }
        
        // ========== å¯¼å…¥å¸ƒå±€ ==========
        function importLayout() {
            document.getElementById('import-file').click();
        }
        
        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // æ¸…ç©ºç°æœ‰å»ºç­‘
                    buildings = { qi: [], bao: [], keng: [], kuang: [] };
                    
                    // å¯¼å…¥æ——
                    if (data.buildings && data.buildings.qi) {
                        buildings.qi = data.buildings.qi.map(b => ({
                            x: b.gameX,
                            y: b.gameY,
                            alliance: b.alliance || 0
                        }));
                    }
                    
                    // å¯¼å…¥å ¡ï¼ˆåŒ…å«åºå·å’Œåç§°ï¼‰
                    if (data.buildings && data.buildings.bao) {
                        buildings.bao = data.buildings.bao.map(b => ({
                            x: b.gameX,
                            y: b.gameY,
                            alliance: b.alliance !== undefined ? b.alliance : null,
                            index: b.index || null,
                            name: b.name || ''
                        }));
                    }
                    
                    // å¯¼å…¥å‘
                    if (data.buildings && data.buildings.keng) {
                        buildings.keng = data.buildings.keng.map(b => ({
                            x: b.gameX,
                            y: b.gameY
                        }));
                    }
                    
                    // å¯¼å…¥çŸ¿
                    if (data.buildings && data.buildings.kuang) {
                        buildings.kuang = data.buildings.kuang.map(b => ({
                            x: b.gameX,
                            y: b.gameY
                        }));
                    }
                    
                    // å¯¼å…¥æ—‹è½¬è§’åº¦
                    if (data.rotation !== undefined) {
                        rotation = data.rotation;
                        document.getElementById('rotation-slider').value = rotation;
                        document.getElementById('rotation-value').textContent = rotation + 'Â°';
                    }
                    
                    updateCoverage();
                    updateStats();
                    render();
                    showValidationMessage(`å·²å¯¼å…¥: æ——${buildings.qi.length} å ¡${buildings.bao.length} å‘${buildings.keng.length} çŸ¿${buildings.kuang.length}`);
                    
                } catch (err) {
                    showValidationMessage('å¯¼å…¥å¤±è´¥: JSONæ ¼å¼é”™è¯¯');
                    console.error('Import error:', err);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // æ¸…ç©ºï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
        }
        
        // ========== ä¿å­˜ä¸ºå›¾ç‰‡ ==========
        function saveAsImage() {
            // åˆ›å»ºä¸´æ—¶canvasæ¥ç»˜åˆ¶å¯¼å‡ºç”¨å›¾ç‰‡
            const tempCanvas = document.createElement('canvas');
            const scale = 2; // 2å€æ¸…æ™°åº¦
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            const tempCtx = tempCanvas.getContext('2d');
            
            // ç¼©æ”¾ä»¥è·å¾—æ›´æ¸…æ™°çš„å›¾ç‰‡
            tempCtx.scale(scale, scale);
            
            // å¤åˆ¶å½“å‰canvaså†…å®¹
            tempCtx.fillStyle = '#0f0f2a';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);
            tempCtx.drawImage(canvas, 0, 0);
            
            // æ·»åŠ ç‰ˆæƒæ°´å°
            tempCtx.globalAlpha = 0.3;
            tempCtx.font = 'bold 24px Arial';
            tempCtx.fillStyle = '#fff';
            tempCtx.textAlign = 'right';
            tempCtx.textBaseline = 'bottom';
            tempCtx.fillText('Â© 2607 é«˜åŸå…”', canvas.width - 20, canvas.height - 20);
            
            // å¯¼å‡ºä¸ºå›¾ç‰‡
            const link = document.createElement('a');
            link.download = 'layout-' + new Date().toISOString().slice(0,10) + '.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
            
            showValidationMessage('å·²ä¿å­˜å›¾ç‰‡');
        }
        
        // ========== åç§°åˆ†é…åŠŸèƒ½ ==========
        let currentModalAlliance = 0;
        const namesByAlliance = { 0: '', 1: '', 2: '', 3: '', 4: '', 5: '' };
        
        function openNameMatcher() {
            document.getElementById('name-modal').classList.add('show');
            switchModalTab(currentModalAlliance);
            updateNamePreview();
        }
        
        function closeNameMatcher() {
            document.getElementById('name-modal').classList.remove('show');
        }
        
        function switchModalTab(allianceId) {
            // ä¿å­˜å½“å‰è¾“å…¥
            namesByAlliance[currentModalAlliance] = document.getElementById('name-input').value;
            
            // åˆ‡æ¢æ ‡ç­¾
            currentModalAlliance = allianceId;
            document.querySelectorAll('.modal-tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === allianceId);
            });
            
            // åŠ è½½å¯¹åº”è”ç›Ÿçš„è¾“å…¥
            document.getElementById('name-input').value = namesByAlliance[allianceId] || '';
            updateNamePreview();
        }
        
        function updateNamePreview() {
            const previewDiv = document.getElementById('name-preview');
            const input = document.getElementById('name-input').value;
            const names = input.split(/[\s\n]+/).filter(n => n.trim());
            
            // è·å–å½“å‰è”ç›Ÿçš„å ¡åˆ—è¡¨ï¼ˆæŒ‰åºå·æ’åºï¼‰
            const baosOfAlliance = buildings.bao
                .filter(b => b.alliance === currentModalAlliance && b.index)
                .sort((a, b) => a.index - b.index);
            
            if (baosOfAlliance.length === 0) {
                previewDiv.innerHTML = '<div style="color:#888;padding:8px;">å½“å‰è”ç›Ÿæ²¡æœ‰æ¿€æ´»çš„å ¡</div>';
                return;
            }
            
            let html = '';
            const maxShow = Math.min(10, Math.max(names.length, baosOfAlliance.length));
            
            for (let i = 0; i < maxShow; i++) {
                const bao = baosOfAlliance[i];
                const name = names[i] || '';
                const indexDisplay = bao ? bao.index : (i + 1);
                const nameDisplay = name || (bao ? (bao.name || '(æœªåˆ†é…)') : '(æ— å ¡)');
                const color = name ? '#00d4ff' : '#666';
                
                html += `<div class="modal-preview-item">
                    <span class="modal-preview-num">${indexDisplay}å·</span>
                    <span class="modal-preview-name" style="color:${color}">${nameDisplay}</span>
                </div>`;
            }
            
            if (names.length > baosOfAlliance.length) {
                html += `<div style="color:#ff6b6b;font-size:10px;padding:4px;">âš ï¸ åç§°æ•°(${names.length})å¤šäºå ¡æ•°(${baosOfAlliance.length})</div>`;
            } else if (baosOfAlliance.length > maxShow) {
                html += `<div style="color:#888;font-size:10px;padding:4px;">... è¿˜æœ‰ ${baosOfAlliance.length - maxShow} ä¸ªå ¡</div>`;
            }
            
            previewDiv.innerHTML = html;
        }
        
        function applyNames() {
            // ä¿å­˜å½“å‰è¾“å…¥
            namesByAlliance[currentModalAlliance] = document.getElementById('name-input').value;
            
            let totalAssigned = 0;
            
            // ä¸ºæ¯ä¸ªè”ç›Ÿåˆ†é…åç§°
            for (let allianceId = 0; allianceId < 6; allianceId++) {
                const names = (namesByAlliance[allianceId] || '').split(/[\s\n]+/).filter(n => n.trim());
                
                // è·å–è¯¥è”ç›Ÿçš„å ¡åˆ—è¡¨ï¼ˆæŒ‰åºå·æ’åºï¼‰
                const baosOfAlliance = buildings.bao
                    .filter(b => b.alliance === allianceId && b.index)
                    .sort((a, b) => a.index - b.index);
                
                // åˆ†é…åç§°
                baosOfAlliance.forEach((bao, i) => {
                    if (i < names.length) {
                        bao.name = names[i];
                        totalAssigned++;
                    }
                });
            }
            
            closeNameMatcher();
            render();
            showValidationMessage(`å·²åˆ†é… ${totalAssigned} ä¸ªåç§°`);
        }
        
        function clearBaoNames() {
            // æ¸…é™¤å½“å‰è”ç›Ÿçš„åç§°
            buildings.bao.forEach(b => {
                if (b.alliance === currentModalAlliance) {
                    b.name = '';
                }
            });
            document.getElementById('name-input').value = '';
            namesByAlliance[currentModalAlliance] = '';
            updateNamePreview();
            render();
            showValidationMessage(`å·²æ¸…é™¤${ALLIANCES[currentModalAlliance].name}å ¡çš„åç§°`);
        }
        
        // ç›‘å¬è¾“å…¥å˜åŒ–æ›´æ–°é¢„è§ˆ
        document.addEventListener('DOMContentLoaded', function() {
            const nameInput = document.getElementById('name-input');
            if (nameInput) {
                nameInput.addEventListener('input', updateNamePreview);
            }
        });
        
        // init() æ”¹ä¸ºåœ¨ç™»å½•æˆåŠŸåç”± initApp() è°ƒç”¨
    </script>
</body>
</html>
