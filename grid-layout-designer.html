<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="å…”å¼Ÿ">
    <meta name="copyright" content="Â© 2026 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š ç‰ˆæƒæ‰€æœ‰">
    <title>ç®¡ç†åŠ©æ‰‹ | 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%2300d4ff'/><stop offset='100%25' style='stop-color:%230066cc'/></linearGradient></defs><circle cx='50' cy='50' r='45' fill='url(%23g)'/><ellipse cx='50' cy='50' rx='45' ry='18' fill='none' stroke='%23fff' stroke-width='2' opacity='0.6'/><ellipse cx='50' cy='50' rx='18' ry='45' fill='none' stroke='%23fff' stroke-width='2' opacity='0.6'/><path d='M10 35 Q50 25 90 35' fill='none' stroke='%234ecca3' stroke-width='3' opacity='0.8'/><path d='M10 65 Q50 75 90 65' fill='none' stroke='%234ecca3' stroke-width='3' opacity='0.8'/></svg>">
    <style>
        /* 
         * ============================================
         * ç®¡ç†åŠ©æ‰‹ - åœ°å›¾è®¾è®¡å¸ƒå±€å·¥å…·
         * Â© 2026 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š ç‰ˆæƒæ‰€æœ‰
         * æŠ€æœ¯æ”¯æŒï¼šå…”å¼Ÿ | æœªç»æˆæƒç¦æ­¢å¤åˆ¶ã€ä¿®æ”¹æˆ–åˆ†å‘
         * ============================================
         */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        html, body { height: 100%; overflow: hidden; touch-action: none; }
        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: linear-gradient(180deg, #E8F4F8 0%, #F5F9FC 100%);
            display: flex;
            color: #fff;
        }
        
        /* å“åº”å¼å¸ƒå±€ */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            
            /* é¡¶éƒ¨å·¥å…·æ  - ç´§å‡‘æ¨ªå‘å¸ƒå±€ */
            .toolbar { 
                width: 100% !important; min-width: 100% !important; 
                flex-direction: row !important; flex-wrap: wrap;
                padding: 6px 8px !important; gap: 4px !important;
                max-height: none; overflow-y: visible;
                border-right: none; border-bottom: 1px solid #C8E0EC;
                padding-bottom: 8px !important;
            }
            .toolbar h2 { display: none; }
            
            /* è”ç›Ÿé€‰æ‹© - æ¨ªå‘æ’åˆ— */
            .alliance-section { 
                flex: 0 0 100%; order: 1; padding: 4px 6px !important;
                background: transparent;
            }
            .alliance-section h3 { display: none; }
            .alliance-grid { 
                grid-template-columns: repeat(6, 1fr) !important; gap: 3px; 
            }
            .alliance-btn { 
                padding: 6px 2px !important; font-size: 8px !important; 
                border-radius: 4px;
            }
            .alliance-btn .alliance-name { font-size: 7px !important; }
            
            /* å»ºç­‘é€‰æ‹© - ç´§å‡‘å›¾æ ‡æŒ‰é’®ç½‘æ ¼å¸ƒå±€ */
            .tool-section { 
                flex: 1 1 auto; order: 2; padding: 2px 4px !important;
                background: rgba(200,224,236,0.2); min-width: auto;
                display: grid !important;
                grid-template-columns: repeat(4, 1fr);
                gap: 3px;
                border-radius: 6px;
            }
            .tool-section h3 { display: none; }
            .tool-section:first-of-type { order: 2; } /* å»ºç­‘é€‰æ‹© */
            .tool-section:last-of-type { order: 3; }  /* å·¥å…· */
            .tool-btn { 
                padding: 10px 4px !important; font-size: 9px !important; 
                margin-bottom: 0 !important;
                flex-direction: column !important;
                justify-content: center;
                width: auto !important;
            }
            .tool-btn span:last-child { 
                display: block !important; 
                font-size: 7px !important; 
                white-space: nowrap;
            }
            .tool-icon { width: 20px !important; height: 20px !important; font-size: 16px !important; }
            
            /* æ—‹è½¬æ§åˆ¶ - ç®€åŒ– */
            .rotation-control { 
                flex: 0 0 auto; order: 4; padding: 4px 8px !important;
                display: flex; flex-direction: row !important; align-items: center; gap: 6px;
                background: rgba(200,224,236,0.2); min-width: auto;
                border-radius: 6px;
            }
            .rotation-control h3 { display: none; }
            .rotation-value { font-size: 11px !important; margin: 0 !important; }
            .rotation-slider { width: 60px !important; margin: 0 !important; }
            .rotation-presets { display: none !important; }
            
            /* æ¡Œé¢ç«¯æ“ä½œæŒ‰é’®åœ¨æ‰‹æœºç«¯éšè—ï¼Œç”±åº•éƒ¨å·¥å…·æ æ›¿ä»£ */
            .action-btns { display: none !important; }
            
            /* å³ä¾§è§„åˆ™é¢æ¿éšè— */
            .rules-panel { display: none !important; }
            
            /* ä¸»åŒºåŸŸ */
            .main-area { flex: 1; padding-bottom: 56px; } /* ä¸ºåº•éƒ¨å·¥å…·æ ç•™ç©ºé—´ */
            
            /* Header - ç®€åŒ–å¸ƒå±€ */
            .header { 
                padding: 4px 8px !important; 
                flex-wrap: wrap;
            }
            .header h1 { 
                font-size: 11px !important; 
                flex: 0 0 auto;
            }
            .header-info { 
                flex: 1; justify-content: flex-end; 
                gap: 6px !important; font-size: 10px !important;
                flex-wrap: wrap;
            }
            .header-info span { padding: 2px 4px !important; }
            .header-info > span:nth-child(n+3) { display: none; } /* éšè—ç¼©æ”¾åé¢çš„å…ƒç´  */
            #btn-zoom-out, #btn-zoom-in { width: 22px !important; height: 22px !important; }
            #btn-zoom-reset { padding: 2px 4px !important; font-size: 9px !important; }
            #btn-remove-watermark { display: none; } /* ç§»åˆ°åº•éƒ¨å·¥å…·æ  */
            
            /* ç‰ˆæƒæ  */
            .copyright-footer { 
                display: none; /* æ‰‹æœºç«¯éšè—åº•éƒ¨ç‰ˆæƒæ ï¼Œé¿å…é®æŒ¡ */
            }
            .copyright-watermark { 
                bottom: 60px; font-size: 8px; 
            }
            
            /* åº•éƒ¨å›ºå®šå·¥å…·æ  */
            .mobile-toolbar {
                display: flex !important;
            }
        }
        
        /* åº•éƒ¨å›ºå®šå·¥å…·æ  - é»˜è®¤éšè—ï¼Œä»…æ‰‹æœºç«¯æ˜¾ç¤º */
        .mobile-toolbar {
            display: none;
            position: fixed;
            bottom: 0; left: 0; right: 0;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid #C8E0EC;
            padding: 6px 8px;
            z-index: 999;
            gap: 6px;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }
        .mobile-toolbar-btn {
            flex: 1;
            max-width: 70px;
            padding: 8px 4px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: #fff;
            font-size: 9px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            transition: transform 0.2s;
        }
        .mobile-toolbar-btn:active { transform: scale(0.95); }
        .mobile-toolbar-btn .mobile-icon { font-size: 16px; }
        .mobile-toolbar-btn.btn-danger { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .mobile-toolbar-btn.btn-success { background: linear-gradient(135deg, #27ae60, #219653); }
        .mobile-toolbar-btn.btn-warning { background: linear-gradient(135deg, #f39c12, #e67e22); }
        
        /* è¶…å°å±å¹• (æ‰‹æœºç«–å±) ä¼˜åŒ– */
        @media (max-width: 480px) {
            .toolbar {
                padding: 4px 6px !important;
            }
            
            /* è”ç›ŸæŒ‰é’® - æ›´ç´§å‡‘ */
            .alliance-grid { 
                grid-template-columns: repeat(6, 1fr) !important;
                gap: 2px !important;
            }
            .alliance-btn { 
                padding: 5px 1px !important; 
                font-size: 10px !important;
            }
            .alliance-btn .alliance-name { display: none !important; }
            
            /* å·¥å…·æŒ‰é’® - æ›´ç´§å‡‘çš„ç½‘æ ¼ */
            .tool-section {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 2px !important;
            }
            .tool-btn {
                padding: 8px 2px !important;
            }
            .tool-btn span:last-child { 
                font-size: 6px !important;
            }
            .tool-icon { font-size: 14px !important; }
            
            /* æ—‹è½¬æ§åˆ¶ - æ›´ç´§å‡‘ */
            .rotation-control {
                padding: 2px 4px !important;
            }
            .rotation-value { font-size: 10px !important; }
            .rotation-slider { width: 50px !important; }
            
            /* Header */
            .header h1 { font-size: 10px !important; }
            .header-info { gap: 4px !important; font-size: 9px !important; }
            #btn-zoom-out, #btn-zoom-in { width: 20px !important; height: 20px !important; font-size: 12px !important; }
            #zoom-level { min-width: 30px !important; font-size: 9px !important; }
            
            /* åº•éƒ¨å·¥å…·æ  - æ›´ç´§å‡‘ */
            .mobile-toolbar {
                padding: 4px 6px;
                gap: 4px;
            }
            .mobile-toolbar-btn {
                padding: 6px 2px;
                font-size: 8px;
                max-width: 60px;
            }
            .mobile-toolbar-btn .mobile-icon { font-size: 14px; }
        }
        
        /* æ¨ªå±æ¨¡å¼ä¼˜åŒ– */
        @media (max-width: 768px) and (orientation: landscape) {
            .toolbar {
                max-height: 100px !important;
                padding: 4px 8px !important;
            }
            .alliance-section {
                flex: 0 0 auto !important;
            }
            .alliance-grid { 
                grid-template-columns: repeat(6, 1fr) !important;
            }
            .tool-section {
                grid-template-columns: repeat(8, 1fr) !important;
            }
            .tool-btn span:last-child { display: none !important; }
            .rotation-control {
                flex: 0 0 auto !important;
            }
            .main-area { padding-bottom: 44px; }
            .mobile-toolbar { padding: 4px; }
            .mobile-toolbar-btn { padding: 4px 2px; font-size: 8px; }
            .mobile-toolbar-btn .mobile-icon { font-size: 12px; }
        }
        
        .toolbar {
            width: 200px;
            min-width: 200px;
            background: rgba(255,255,255,0.85);
            padding: 12px;
            padding-bottom: 35px;  /* é¿å…è¢«ç‰ˆæƒæ é®æŒ¡ */
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-right: 1px solid #C8E0EC;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 2px 0 10px rgba(168,200,216,0.3);
        }
        .toolbar h2 { color: #2980b9; font-size: 16px; text-align: center; padding-bottom: 8px; border-bottom: 1px solid #C8E0EC; }
        
        /* åœ°çƒé—ªçƒåŠ¨ç”» */
        @keyframes sparkle {
            0%, 100% { filter: drop-shadow(0 0 3px #00d4ff) drop-shadow(0 0 6px #fff); transform: scale(1); }
            25% { filter: drop-shadow(0 0 8px #00d4ff) drop-shadow(0 0 15px #fff); transform: scale(1.05); }
            50% { filter: drop-shadow(0 0 5px #4ecca3) drop-shadow(0 0 10px #fff); transform: scale(1.02); }
            75% { filter: drop-shadow(0 0 10px #00d4ff) drop-shadow(0 0 20px #fff); transform: scale(1.08); }
        }
        .logo-earth {
            display: inline-block;
            animation: sparkle 2s ease-in-out infinite;
            font-size: 24px;
            vertical-align: middle;
            margin-right: 5px;
        }
        .tool-section { background: rgba(200,224,236,0.3); padding: 10px; border-radius: 8px; }
        .tool-section h3 { font-size: 11px; color: #5a7a8a; margin-bottom: 6px; }
        .tool-btn {
            width: 100%; padding: 8px; margin-bottom: 4px;
            border: 2px solid transparent; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 12px;
            display: flex; align-items: center; gap: 6px;
            transition: all 0.2s;
        }
        .tool-btn:hover { transform: scale(1.02); }
        .tool-btn.active { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.3); }
        .tool-btn-qi { background: linear-gradient(135deg, #6495ED, #4169E1); color: #fff; }
        .tool-btn-bao { background: linear-gradient(135deg, #4ecca3, #2ed573); color: #fff; }
        .tool-btn-keng { background: linear-gradient(135deg, #ff6b6b, #ee5253); color: #fff; }
        .tool-btn-kuang { background: linear-gradient(135deg, #ffd93d, #f39c12); color: #333; }
        .tool-btn-delete { background: linear-gradient(135deg, #636e72, #2d3436); color: #fff; }
        .tool-btn-move { background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: #fff; }
        .tool-btn-pointer { background: linear-gradient(135deg, #fd79a8, #e84393); color: #fff; }
        .tool-btn-drag { background: linear-gradient(135deg, #00b894, #00a085); color: #fff; }
        .tool-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 11px; }
        
        /* è”ç›Ÿé€‰æ‹© */
        .alliance-section { background: rgba(200,224,236,0.3); padding: 10px; border-radius: 8px; }
        .alliance-section h3 { font-size: 11px; color: #2c3e50; margin-bottom: 6px; font-weight: bold; }
        .alliance-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; }
        .alliance-btn {
            padding: 8px 4px; border: 2px solid rgba(0,0,0,0.2); border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 10px;
            display: flex; flex-direction: column; align-items: center; gap: 2px;
            transition: all 0.2s;
            color: #1a252f;  /* æ·±è‰²å­—ä½“ï¼Œæ¸…æ™°å¯è§ */
            text-shadow: 0 0 3px rgba(255,255,255,0.8);  /* æ·»åŠ æ–‡å­—é˜´å½±å¢å¼ºå¯è¯»æ€§ */
        }
        .alliance-btn:hover { transform: scale(1.05); border-color: rgba(0,0,0,0.4); }
        .alliance-btn.active { border-color: #2980b9; box-shadow: 0 0 10px rgba(41,128,185,0.5); }
        .alliance-color { width: 20px; height: 20px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3); }
        
        .rotation-control { background: rgba(200,224,236,0.3); padding: 10px; border-radius: 8px; }
        .rotation-control h3 { font-size: 11px; color: #5a7a8a; margin-bottom: 6px; }
        .rotation-slider { width: 100%; margin: 6px 0; }
        .rotation-value { text-align: center; color: #2980b9; font-weight: bold; font-size: 16px; }
        .rotation-presets { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 6px; }
        .rotation-preset { padding: 4px 8px; background: rgba(255,255,255,0.1); border: none; border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px; }
        .rotation-preset:hover { background: rgba(255,255,255,0.2); }
        .rotation-preset.active { background: #00d4ff; color: #000; }
        
        .stats-panel { background: rgba(200,224,236,0.3); padding: 10px; border-radius: 8px; }
        .stat-row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px; }
        .stat-label { color: #5a7a8a; }
        .stat-value { color: #2980b9; font-weight: bold; }
        .stat-value.success { color: #4ecca3; }
        .stat-value.warning { color: #ffd93d; }
        .stat-value.error { color: #ff6b6b; }
        
        .action-btns { display: flex; flex-direction: column; gap: 4px; }
        .action-btn { padding: 6px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }
        .btn-clear { background: #ff6b6b; color: #fff; }
        .btn-export { background: #4ecca3; color: #fff; }
        .btn-auto { background: #ffd93d; color: #333; }
        .btn-center { background: #a29bfe; color: #fff; }
        
        .shortcuts { font-size: 9px; color: #5a7a8a; padding: 6px; background: rgba(200,224,236,0.3); border-radius: 4px; }
        .shortcuts kbd { background: rgba(41,128,185,0.15); padding: 1px 4px; border-radius: 2px; color: #2980b9; }
        
        .main-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .header { padding: 8px 15px; background: rgba(255,255,255,0.8); display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #C8E0EC; }
        .header h1 { color: #2980b9; font-size: 16px; }
        .header-info { display: flex; gap: 12px; font-size: 11px; color: #5a7a8a; }
        .header-info span { background: rgba(200,224,236,0.5); padding: 3px 8px; border-radius: 4px; }
        .header-info .highlight { background: rgba(41, 128, 185, 0.2); color: #2980b9; font-weight: bold; }
        
        .canvas-wrapper { flex: 1; overflow: hidden; background: linear-gradient(135deg, #E0F4FF 0%, #F0F8FF 50%, #FAFEFE 100%); position: relative; }
        canvas { display: block; cursor: crosshair; }
        
        .rules-panel {
            width: 220px; min-width: 220px;
            background: rgba(255,255,255,0.85);
            padding: 12px;
            border-left: 1px solid #C8E0EC;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        .rules-panel h2 { color: #2980b9; font-size: 14px; margin-bottom: 10px; }
        
        /* ç‰ˆæƒæ°´å° */
        .copyright-watermark {
            position: fixed; bottom: 10px; right: 10px;
            color: rgba(41, 128, 185, 0.2); font-size: 11px;
            pointer-events: none; z-index: 9999;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        .copyright-footer {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: rgba(255,255,255,0.9); color: #5a7a8a;
            text-align: center; padding: 4px; font-size: 10px;
            border-top: 1px solid #C8E0EC;
            z-index: 1000;
        }
        .copyright-footer a { color: #2980b9; text-decoration: none; }
        /* ç§»åŠ¨ç«¯ç‰ˆæƒæ ·å¼ç”±ä¸Šæ–¹ä¸»è¦åª’ä½“æŸ¥è¯¢å¤„ç† */
        
        /* å¼¹çª—æ ·å¼ */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); z-index: 2000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: #1a1a2e; border-radius: 12px; padding: 20px;
            max-width: 500px; width: 90%; max-height: 80vh;
            border: 2px solid #00d4ff; box-shadow: 0 0 30px rgba(0,212,255,0.3);
        }
        .modal h3 { color: #00d4ff; margin-bottom: 15px; font-size: 16px; }
        .modal-tabs { display: flex; gap: 8px; margin-bottom: 15px; }
        .modal-tab {
            padding: 8px 16px; border: none; border-radius: 6px;
            background: rgba(255,255,255,0.1); color: #888; cursor: pointer;
            font-size: 12px;
        }
        .modal-tab.active { background: #00d4ff; color: #000; }
        .modal textarea {
            width: 100%; height: 150px; background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
            color: #fff; padding: 10px; font-size: 12px; resize: none;
            font-family: inherit;
        }
        .modal textarea:focus { outline: none; border-color: #00d4ff; }
        .modal-hint { color: #888; font-size: 10px; margin: 8px 0; }
        .modal-preview {
            max-height: 120px; overflow-y: auto; background: rgba(0,0,0,0.3);
            border-radius: 6px; padding: 8px; margin: 10px 0;
        }
        .modal-preview-item {
            display: flex; justify-content: space-between; padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 11px;
        }
        .modal-preview-item:last-child { border-bottom: none; }
        .modal-preview-num { color: #00d4ff; font-weight: bold; }
        .modal-preview-name { color: #fff; }
        .modal-btns { display: flex; gap: 10px; margin-top: 15px; }
        .modal-btn {
            flex: 1; padding: 10px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 12px;
        }
        .modal-btn-primary { background: #00d4ff; color: #000; }
        .modal-btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        
        /* ç™»å½•ç•Œé¢æ ·å¼ - å†¬æ—¥é›ªæ™¯ */
        .login-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 30%, #E0F4FF 60%, #F5F9FC 100%);
            z-index: 9999; display: flex; justify-content: center; align-items: center;
            overflow: hidden;
        }
        .login-overlay::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #fff, transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(2px 2px at 130px 80px, rgba(255,255,255,0.9), transparent),
                radial-gradient(1px 1px at 160px 30px, #fff, transparent);
            background-size: 200px 100px;
            animation: snowfall 8s linear infinite;
            opacity: 0.8;
        }
        @keyframes snowfall {
            0% { background-position: 0 0, 0 0, 0 0, 0 0, 0 0; }
            100% { background-position: 200px 300px, 100px 400px, 150px 350px, 50px 450px, 180px 380px; }
        }
        .login-overlay.hidden { display: none; }
        .login-box {
            background: rgba(255,255,255,0.85); border-radius: 20px; padding: 40px;
            border: 1px solid rgba(255,255,255,0.9); 
            box-shadow: 0 8px 32px rgba(135,206,235,0.3), 0 0 60px rgba(255,255,255,0.5);
            text-align: center; min-width: 320px;
            backdrop-filter: blur(10px);
            position: relative; z-index: 1;
        }
        .login-box h2 { color: #2980b9; font-size: 24px; margin-bottom: 8px; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); }
        .login-box .subtitle { color: #5a7a8a; font-size: 12px; margin-bottom: 30px; }
        .login-input {
            width: 100%; padding: 12px 16px; margin-bottom: 16px;
            background: rgba(255,255,255,0.9); border: 1px solid #B0E0E6;
            border-radius: 10px; color: #2c3e50; font-size: 14px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .login-input:focus { outline: none; border-color: #3498db; box-shadow: 0 0 10px rgba(52,152,219,0.3); }
        .login-input::placeholder { color: #95a5a6; }
        .login-btn {
            width: 100%; padding: 14px; 
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: none; border-radius: 10px; color: #fff; font-size: 14px;
            font-weight: bold; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .login-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(52,152,219,0.4); }
        .login-btn:active { transform: translateY(0); }
        .login-error {
            color: #e74c3c; font-size: 12px; margin-top: 12px;
            min-height: 18px; transition: opacity 0.3s;
        }
        .login-footer { color: #7f8c8d; font-size: 10px; margin-top: 30px; }
        
        .rule-item { background: rgba(255,255,255,0.05); padding: 8px; border-radius: 6px; margin-bottom: 6px; border-left: 3px solid #4ecca3; }
        .rule-item.warning { border-left-color: #ffd93d; }
        .rule-item.info { border-left-color: #6495ED; }
        .rule-item h4 { color: #fff; font-size: 11px; margin-bottom: 3px; }
        .rule-item p { color: #888; font-size: 9px; line-height: 1.4; }
        
        .coord-info { background: rgba(0,212,255,0.1); padding: 8px; border-radius: 6px; margin-bottom: 8px; border: 1px solid rgba(0,212,255,0.3); }
        .coord-info h4 { color: #00d4ff; font-size: 11px; margin-bottom: 4px; }
        .coord-info p { color: #aaa; font-size: 9px; line-height: 1.5; }
        
        .building-info {
            position: fixed; background: rgba(255,255,255,0.98); color: #2c3e50;
            padding: 10px 14px; border-radius: 8px; font-size: 11px;
            pointer-events: none; z-index: 1001; display: none;
            border: 2px solid #2980b9; min-width: 140px;
            box-shadow: 0 4px 15px rgba(41,128,185,0.3);
        }
        .building-info-title { font-size: 13px; font-weight: bold; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #C8E0EC; }
        .building-info-coord { color: #2980b9; font-size: 18px; font-weight: bold; text-align: center; margin: 6px 0; }
        .building-info-note { color: #5a7a8a; font-size: 9px; text-align: center; }
        .building-info-status { margin-top: 4px; padding-top: 4px; border-top: 1px solid #C8E0EC; font-size: 10px; }
        .building-info-status.active { color: #27ae60; }
        .building-info-status.inactive { color: #95a5a6; }
        
        .tooltip {
            position: fixed; background: rgba(255,255,255,0.98); color: #2c3e50;
            padding: 8px 12px; border-radius: 6px; font-size: 11px;
            pointer-events: none; z-index: 1000; display: none;
            border: 1px solid #C8E0EC; line-height: 1.5;
            box-shadow: 0 2px 10px rgba(41,128,185,0.2);
        }
        .tooltip.error { background: rgba(231,76,60,0.95); border-color: #c0392b; color: #fff; }
        .tooltip.success { background: rgba(255,255,255,0.98); border-color: #27ae60; color: #2c3e50; }
        
        /* è¾¹ç•Œè­¦å‘Š */
        .boundary-warning {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 107, 107, 0.9); color: #fff;
            padding: 6px 12px; border-radius: 4px; font-size: 11px;
            display: none;
        }
    </style>
</head>
<body>
    <!-- ç™»å½•ç•Œé¢ -->
    <div class="login-overlay" id="login-overlay">
        <!-- é›ªå±±è£…é¥° -->
        <svg class="snow-mountain" viewBox="0 0 1200 200" preserveAspectRatio="none" style="position:absolute;bottom:0;left:0;width:100%;height:25%;opacity:0.6;">
            <defs>
                <linearGradient id="mountain1" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#fff"/>
                    <stop offset="40%" style="stop-color:#E8F4F8"/>
                    <stop offset="100%" style="stop-color:#B8D4E3"/>
                </linearGradient>
                <linearGradient id="mountain2" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#F0F8FF"/>
                    <stop offset="100%" style="stop-color:#A8C8D8"/>
                </linearGradient>
            </defs>
            <path d="M0 200 L0 120 L150 60 L250 100 L400 30 L500 80 L650 20 L800 70 L900 40 L1050 90 L1200 50 L1200 200 Z" fill="url(#mountain2)"/>
            <path d="M0 200 L0 150 L100 100 L200 130 L350 70 L450 110 L600 50 L750 100 L850 60 L1000 120 L1100 80 L1200 110 L1200 200 Z" fill="url(#mountain1)"/>
        </svg>
        <!-- æ¾æ ‘è£…é¥° -->
        <svg class="pine-trees" viewBox="0 0 100 50" preserveAspectRatio="xMidYMax meet" style="position:absolute;bottom:8%;left:5%;width:60px;height:80px;opacity:0.4;">
            <path d="M50 0 L35 20 L40 20 L30 35 L38 35 L25 50 L75 50 L62 35 L70 35 L60 20 L65 20 Z" fill="#2E5A4C"/>
            <rect x="45" y="50" width="10" height="8" fill="#5D4037"/>
        </svg>
        <svg class="pine-trees" viewBox="0 0 100 50" preserveAspectRatio="xMidYMax meet" style="position:absolute;bottom:10%;right:8%;width:45px;height:60px;opacity:0.3;">
            <path d="M50 0 L35 20 L40 20 L30 35 L38 35 L25 50 L75 50 L62 35 L70 35 L60 20 L65 20 Z" fill="#2E5A4C"/>
            <rect x="45" y="50" width="10" height="8" fill="#5D4037"/>
        </svg>
        <div class="login-box">
            <h2><span class="logo-earth">ğŸŒ</span> ç®¡ç†åŠ©æ‰‹</h2>
            <div class="subtitle">â„ï¸ è¯·è¾“å…¥è´¦å·å¯†ç ç™»å½• â„ï¸</div>
            <input type="text" class="login-input" id="login-username" placeholder="ç”¨æˆ·å" autocomplete="off">
            <input type="password" class="login-input" id="login-password" placeholder="å¯†ç " autocomplete="off">
            <button class="login-btn" onclick="handleLogin()">ç™» å½•</button>
            <div class="login-error" id="login-error"></div>
            <div class="login-footer">Â© 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š | æŠ€æœ¯ï¼šå…”å¼Ÿ</div>
        </div>
    </div>
    
    <div class="toolbar">
        <h2><span class="logo-earth">ğŸŒ</span> ç®¡ç†åŠ©æ‰‹</h2>
        
        <div class="alliance-section">
            <h3>ğŸ´ é€‰æ‹©è”ç›Ÿ</h3>
            <div class="alliance-grid" id="alliance-grid">
                <!-- è”ç›ŸæŒ‰é’®ç”±JSç”Ÿæˆ -->
            </div>
        </div>
        
        <div class="tool-section">
            <h3>é€‰æ‹©å»ºç­‘</h3>
            <button class="tool-btn tool-btn-qi" onclick="selectTool('qi')" id="tool-qi">
                <span class="tool-icon">ğŸš©</span><span>æ—— (7Ã—7)</span>
            </button>
            <button class="tool-btn tool-btn-bao" onclick="selectTool('bao')" id="tool-bao">
                <span class="tool-icon">ğŸ°</span><span>å ¡ (2Ã—2)</span>
            </button>
            <button class="tool-btn tool-btn-keng" onclick="selectTool('keng')" id="tool-keng">
                <span class="tool-icon">â­•</span><span>å‘ (3Ã—3)</span>
            </button>
            <button class="tool-btn tool-btn-kuang" onclick="selectTool('kuang')" id="tool-kuang">
                <span class="tool-icon">ğŸ’</span><span>çŸ¿ (2Ã—2)</span>
            </button>
        </div>
        
        <div class="tool-section">
            <h3>å·¥å…·</h3>
            <button class="tool-btn tool-btn-pointer" onclick="selectTool('pointer')" id="tool-pointer">
                <span class="tool-icon">ğŸ‘†</span><span>æŸ¥çœ‹åæ ‡</span>
            </button>
            <button class="tool-btn tool-btn-move active" onclick="selectTool('move')" id="tool-move">
                <span class="tool-icon">âœ‹</span><span>ç§»åŠ¨ç”»å¸ƒ</span>
            </button>
            <button class="tool-btn tool-btn-drag" onclick="selectTool('drag')" id="tool-drag">
                <span class="tool-icon">ğŸ”€</span><span>æ‹–åŠ¨å»ºç­‘</span>
            </button>
            <button class="tool-btn tool-btn-delete" onclick="selectTool('delete')" id="tool-delete">
                <span class="tool-icon">ğŸ—‘ï¸</span><span>åˆ é™¤å»ºç­‘</span>
            </button>
        </div>
        
        <div class="rotation-control">
            <h3>ğŸ”„ ç”»å¸ƒæ—‹è½¬</h3>
            <div class="rotation-value"><span id="rotation-display">45</span>Â°</div>
            <input type="range" class="rotation-slider" id="rotation-slider" min="0" max="360" value="45" step="15" oninput="setRotation(this.value)">
            <div class="rotation-presets">
                <button class="rotation-preset active" onclick="setRotation(0)">0Â°</button>
                <button class="rotation-preset" onclick="setRotation(45)">45Â°</button>
                <button class="rotation-preset" onclick="setRotation(90)">90Â°</button>
                <button class="rotation-preset" onclick="setRotation(180)">180Â°</button>
            </div>
        </div>
        
        <div class="action-btns">
            <button class="action-btn btn-center" onclick="centerView()">å›åˆ°ä¸­å¿ƒ</button>
            <button class="action-btn btn-auto" onclick="autoFillBao()">è‡ªåŠ¨å¡«å……å ¡</button>
            <button class="action-btn btn-auto" onclick="openNameMatcher()">ğŸ° åˆ†é…åç§°</button>
            <button class="action-btn btn-export" onclick="exportLayout()">ğŸ“¤ å¯¼å‡ºJSON</button>
            <button class="action-btn btn-export" onclick="importLayout()">ğŸ“¥ å¯¼å…¥JSON</button>
            <button class="action-btn btn-export" onclick="saveAsImage()">ğŸ–¼ï¸ ä¿å­˜å›¾ç‰‡</button>
            <button class="action-btn btn-clear" onclick="clearAll()">æ¸…ç©ºå…¨éƒ¨</button>
        </div>
        <input type="file" id="import-file" accept=".json" style="display:none" onchange="handleImport(event)">
    </div>
    
    <div class="main-area">
        <div class="header">
            <h1>ğŸ¯ åœ°å›¾è®¾è®¡</h1>
            <div class="header-info">
                <span class="highlight">åæ ‡: <span id="mouse-game">(600, 600)</span></span>
                <span style="display:flex;align-items:center;gap:4px;">
                    ç¼©æ”¾: 
                    <button id="btn-zoom-out" style="width:24px;height:24px;border:none;border-radius:4px;background:#2980b9;color:#fff;cursor:pointer;font-weight:bold;">âˆ’</button>
                    <span id="zoom-level" style="min-width:40px;text-align:center;">100%</span>
                    <button id="btn-zoom-in" style="width:24px;height:24px;border:none;border-radius:4px;background:#2980b9;color:#fff;cursor:pointer;font-weight:bold;">+</button>
                    <button id="btn-zoom-reset" style="padding:2px 6px;border:none;border-radius:4px;background:#5a7a8a;color:#fff;cursor:pointer;font-size:10px;">é‡ç½®</button>
                </span>
                <button id="btn-remove-watermark" onclick="removeWatermark()" style="padding:2px 8px;border:none;border-radius:4px;background:#e67e22;color:#fff;cursor:pointer;font-size:10px;">ğŸ”“ å»æ°´å°</button>
                <span id="boundary-status"></span>
            </div>
        </div>
        <div class="canvas-wrapper" id="canvas-wrapper">
            <canvas id="canvas"></canvas>
            <div class="boundary-warning" id="boundary-warning">âš  è¶…å‡ºåœ°å›¾è¾¹ç•Œ</div>
        </div>
    </div>
    
    <div class="rules-panel">
        <h2>âŒ¨ï¸ å¿«æ·é”®</h2>
        <div class="shortcuts">
            <div><kbd>1</kbd>æ—— <kbd>2</kbd>å ¡ <kbd>3</kbd>å‘ <kbd>4</kbd>çŸ¿ <kbd>5</kbd>æ‹–åŠ¨</div>
            <div><kbd>P</kbd>æŸ¥çœ‹ <kbd>D</kbd>åˆ é™¤ <kbd>ç©ºæ ¼</kbd>ç§»åŠ¨</div>
            <div><kbd>Q</kbd>/<kbd>E</kbd>åˆ‡æ¢è”ç›Ÿ <kbd>C</kbd>å›ä¸­å¿ƒ <kbd>Esc</kbd>å–æ¶ˆé€‰æ‹©</div>
        </div>
        
        <h2>ğŸ“Š ç»Ÿè®¡</h2>
        
        <div class="stats-panel">
            <div id="alliance-stats">
                <!-- è”ç›Ÿç»Ÿè®¡ç”±JSç”Ÿæˆ -->
            </div>
            <div style="border-top: 1px solid #C8E0EC; margin-top: 6px; padding-top: 6px;">
                <div class="stat-row"><span class="stat-label">ğŸ° å ¡(ç”Ÿæ•ˆ)</span><span class="stat-value success" id="stat-bao-active">0</span></div>
                <div class="stat-row"><span class="stat-label">ğŸ° å ¡(æœªç”Ÿæ•ˆ)</span><span class="stat-value warning" id="stat-bao-inactive">0</span></div>
                <div class="stat-row"><span class="stat-label">â­• å‘</span><span class="stat-value" id="stat-keng">0</span></div>
                <div class="stat-row"><span class="stat-label">ğŸ’ çŸ¿</span><span class="stat-value" id="stat-kuang">0</span></div>
            </div>
        </div>
        
        <h2>ğŸ“‹ è§„åˆ™</h2>
        
        <div class="coord-info">
            <h4>ğŸ“ åæ ‡ç³»ç»Ÿ</h4>
            <p>â€¢ Xè½´å‘ä¸Šå¢å¤§ï¼ŒYè½´å‘å·¦å¢å¤§<br>
               â€¢ å³ä¸‹<strong>(0,0)</strong> å·¦ä¸Š<strong>(1199,1199)</strong><br>
               â€¢ å³ä¸Š<strong>(1199,0)</strong> å·¦ä¸‹<strong>(0,1199)</strong><br>
               â€¢ æ——/å‘: <strong>ä¸­å¿ƒåæ ‡</strong><br>
               â€¢ å ¡/çŸ¿/NPC: <strong>(Xæœ€å¤§,Yæœ€å°)</strong></p>
        </div>
        
        <div class="rule-item info"><h4>ğŸš© æ—— 7Ã—7</h4><p>6è”ç›Ÿä¸åŒè‰² | åŒç›Ÿç›¸è¿=æ¿€æ´»</p></div>
        <div class="rule-item"><h4>ğŸ° å ¡ 2Ã—2</h4><p>æ——å†…=ç»¿(ç”Ÿæ•ˆ) | æ——å¤–=ç°(ä¸ç”Ÿæ•ˆ)</p></div>
        <div class="rule-item warning"><h4>â­• å‘ 3Ã—3</h4><p>å¯æ”¾å¤šä¸ª | ä¸èƒ½é‡å </p></div>
        <div class="rule-item"><h4>ğŸ’ çŸ¿ 2Ã—2</h4><p>ä»»æ„ä½ç½®</p></div>
        <div class="rule-item" style="border-left-color: #666;"><h4>ğŸ›ï¸ NPCå»ºç­‘</h4><p>ä¸œå—è¥¿åŒ—å››æ–¹ | å›ºå®šæ˜¾ç¤ºä¸å¯åˆ é™¤</p></div>
        
        <h2>ğŸ—ºï¸ ç‰¹æ®ŠåŒºåŸŸ</h2>
        <div class="rule-item" style="border-left-color: rgba(144, 238, 144, 0.8);"><h4>ğŸŒ¿ æ²ƒåœŸ</h4><p>æ·¡ç»¿è‰² | (450~749)</p></div>
        <div class="rule-item" style="border-left-color: rgba(128, 128, 128, 0.8);"><h4>ğŸª¨ é»‘åœŸ</h4><p>æ·¡ç°è‰² | (552~647)</p></div>
        <div class="rule-item" style="border-left-color: rgba(255, 100, 100, 0.8);"><h4>ğŸ”¥ çº¢åœŸ</h4><p>æ·¡çº¢è‰² | (586~613)</p></div>
        
        <div class="rule-item warning">
            <h4>ğŸ’¡ æç¤º</h4>
            <p id="validation-msg">æ‚¬åœå»ºç­‘æŸ¥çœ‹åæ ‡</p>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    <div class="building-info" id="building-info">
        <div class="building-info-title" id="building-info-title">ğŸš© æ——</div>
        <div class="building-info-coord" id="building-info-coord">(100, 200)</div>
        <div class="building-info-note" id="building-info-note">ä¸­å¿ƒåæ ‡</div>
        <div class="building-info-status" id="building-info-status"></div>
    </div>
    
    <!-- ç‰ˆæƒä¿¡æ¯ -->
    <div class="copyright-watermark">Â© 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š</div>
    <div class="copyright-footer">
        <span class="logo-earth">ğŸŒ</span> ç®¡ç†åŠ©æ‰‹ v1.0 | ç‰ˆæƒï¼š<strong>2607å…¨æ°‘ä»£è¡¨å¤§ä¼š</strong> | æ”¯æŒï¼š2607ç®¡ç†å§”å‘˜ä¼š | æŠ€æœ¯ï¼šå…”å¼Ÿ
    </div>
    
    <!-- ç§»åŠ¨ç«¯åº•éƒ¨å·¥å…·æ  -->
    <div class="mobile-toolbar" id="mobile-toolbar">
        <button class="mobile-toolbar-btn" onclick="centerView()">
            <span class="mobile-icon">ğŸ¯</span>
            <span>å›ä¸­å¿ƒ</span>
        </button>
        <button class="mobile-toolbar-btn btn-success" onclick="exportLayout()">
            <span class="mobile-icon">ğŸ“¤</span>
            <span>å¯¼å‡º</span>
        </button>
        <button class="mobile-toolbar-btn btn-success" onclick="importLayout()">
            <span class="mobile-icon">ğŸ“¥</span>
            <span>å¯¼å…¥</span>
        </button>
        <button class="mobile-toolbar-btn" onclick="saveAsImage()">
            <span class="mobile-icon">ğŸ–¼ï¸</span>
            <span>ä¿å­˜å›¾</span>
        </button>
        <button class="mobile-toolbar-btn btn-warning" onclick="removeWatermark()">
            <span class="mobile-icon">ğŸ”“</span>
            <span>å»æ°´å°</span>
        </button>
        <button class="mobile-toolbar-btn btn-danger" onclick="clearAll()">
            <span class="mobile-icon">ğŸ—‘ï¸</span>
            <span>æ¸…ç©º</span>
        </button>
    </div>
    
    <!-- åç§°åˆ†é…å¼¹çª— -->
    <div class="modal-overlay" id="name-modal">
        <div class="modal">
            <h3>ğŸ° å ¡å’åç§°åˆ†é…</h3>
            <div class="modal-tabs">
                <button class="modal-tab active" onclick="switchModalTab(0)">çº¢ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(1)">è“ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(2)">ç»¿ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(3)">é»„ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(4)">ç´«ç›Ÿ</button>
                <button class="modal-tab" onclick="switchModalTab(5)">æ©™ç›Ÿ</button>
            </div>
            <textarea id="name-input" placeholder="è¾“å…¥äººå‘˜åç§°ï¼Œæ¯è¡Œä¸€ä¸ªæˆ–ç”¨ç©ºæ ¼åˆ†éš”&#10;ä¾‹å¦‚ï¼š&#10;å¼ ä¸‰&#10;æå››&#10;ç‹äº”"></textarea>
            <div class="modal-hint">ğŸ’¡ åç§°å°†æŒ‰é¡ºåºåˆ†é…ç»™å½“å‰è”ç›Ÿçš„å ¡ï¼Œä»åºå·1å¼€å§‹</div>
            <div class="modal-preview" id="name-preview"></div>
            <div class="modal-btns">
                <button class="modal-btn modal-btn-secondary" onclick="closeNameMatcher()">å–æ¶ˆ</button>
                <button class="modal-btn modal-btn-secondary" onclick="clearBaoNames()">æ¸…é™¤åç§°</button>
                <button class="modal-btn modal-btn-primary" onclick="applyNames()">åº”ç”¨åˆ†é…</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * ============================================
         * ç®¡ç†åŠ©æ‰‹ - åœ°å›¾è®¾è®¡å¸ƒå±€å·¥å…·
         * Â© 2026 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š ç‰ˆæƒæ‰€æœ‰
         * æŠ€æœ¯æ”¯æŒï¼šå…”å¼Ÿ | æœªç»æˆæƒç¦æ­¢å¤åˆ¶ã€ä¿®æ”¹æˆ–åˆ†å‘æœ¬ç¨‹åº
         * ============================================
         */
        
        // ç‰ˆæƒä¿æŠ¤æªæ–½
        (function() {
            // ç¦ç”¨å³é”®èœå•
            document.addEventListener('contextmenu', function(e) {
                if (e.target.tagName !== 'CANVAS') e.preventDefault();
            });
            // ç¦ç”¨F12å’ŒCtrl+Shift+I
            document.addEventListener('keydown', function(e) {
                if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
                    e.preventDefault();
                }
            });
            // æ§åˆ¶å°è­¦å‘Š
            console.log('%câš ï¸ ç‰ˆæƒå£°æ˜', 'color: #e74c3c; font-size: 20px; font-weight: bold;');
            console.log('%cæœ¬ç¨‹åºç”± 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š æˆæƒï¼ŒæŠ€æœ¯æ”¯æŒï¼šå…”å¼Ÿï¼Œæœªç»æˆæƒç¦æ­¢å¤åˆ¶ã€ä¿®æ”¹æˆ–åˆ†å‘ã€‚', 'color: #f39c12; font-size: 14px;');
        })();
        
        // ========== ç™»å½•éªŒè¯ ==========
        const AUTH_USER = '2607';
        const AUTH_PASS = 'godm';
        
        function checkLogin() {
            return sessionStorage.getItem('loggedIn') === 'true';
        }
        
        function handleLogin() {
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            const errorEl = document.getElementById('login-error');
            
            if (username === AUTH_USER && password === AUTH_PASS) {
                sessionStorage.setItem('loggedIn', 'true');
                document.getElementById('login-overlay').classList.add('hidden');
                errorEl.textContent = '';
                initApp();
            } else {
                errorEl.textContent = 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯';
                document.getElementById('login-password').value = '';
            }
        }
        
        // å›è½¦é”®ç™»å½•
        document.addEventListener('DOMContentLoaded', function() {
            const usernameInput = document.getElementById('login-username');
            const passwordInput = document.getElementById('login-password');
            
            usernameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') passwordInput.focus();
            });
            passwordInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') handleLogin();
            });
            
            // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
            if (checkLogin()) {
                document.getElementById('login-overlay').classList.add('hidden');
                initApp();
            } else {
                usernameInput.focus();
            }
        });
        
        function initApp() {
            // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿DOMå®Œå…¨åŠ è½½
            setTimeout(init, 100);
        }
        
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const buildingInfo = document.getElementById('building-info');
        const boundaryWarning = document.getElementById('boundary-warning');
        
        // é…ç½®
        const CELL_SIZE = 10;
        const GAME_SIZE = 1200;
        const MAX_COORD = 1199;
        
        // è”ç›Ÿé…ç½®ï¼ˆ6ä¸ªè”ç›Ÿï¼‰
        const ALLIANCES = [
            { id: 0, name: 'çº¢ç›Ÿ', color: '#e74c3c', colorActive: 'rgba(231, 76, 60, 0.5)', colorInactive: 'rgba(231, 76, 60, 0.2)', borderActive: '#e74c3c', borderInactive: '#7a3d3d' },
            { id: 1, name: 'è“ç›Ÿ', color: '#3498db', colorActive: 'rgba(52, 152, 219, 0.5)', colorInactive: 'rgba(52, 152, 219, 0.2)', borderActive: '#3498db', borderInactive: '#2a5a7a' },
            { id: 2, name: 'ç»¿ç›Ÿ', color: '#2ecc71', colorActive: 'rgba(46, 204, 113, 0.5)', colorInactive: 'rgba(46, 204, 113, 0.2)', borderActive: '#2ecc71', borderInactive: '#1e7a46' },
            { id: 3, name: 'é»„ç›Ÿ', color: '#f1c40f', colorActive: 'rgba(241, 196, 15, 0.5)', colorInactive: 'rgba(241, 196, 15, 0.2)', borderActive: '#f1c40f', borderInactive: '#9a7d0a' },
            { id: 4, name: 'ç´«ç›Ÿ', color: '#9b59b6', colorActive: 'rgba(155, 89, 182, 0.5)', colorInactive: 'rgba(155, 89, 182, 0.2)', borderActive: '#9b59b6', borderInactive: '#5d3570' },
            { id: 5, name: 'æ©™ç›Ÿ', color: '#e67e22', colorActive: 'rgba(230, 126, 34, 0.5)', colorInactive: 'rgba(230, 126, 34, 0.2)', borderActive: '#e67e22', borderInactive: '#8a4c14' }
        ];
        
        const BUILDING_CONFIG = {
            qi:    { size: 7, name: 'æ——', icon: 'ğŸš©', coordType: 'center' },
            bao:   { size: 2, colorActive: '#4ecca3', colorInactive: '#636e72', border: '#2ed573', name: 'å ¡', icon: 'ğŸ°', coordType: 'bottomRight' },
            keng:  { size: 3, color: 'rgba(255, 107, 107, 0.6)', border: '#ee5253', name: 'å‘', icon: 'â­•', coordType: 'center' },
            kuang: { size: 2, color: '#ffd93d', border: '#f39c12', name: 'çŸ¿', icon: 'ğŸ’', coordType: 'bottomRight' }
        };
        
        // NPCå»ºç­‘é…ç½®ï¼ˆå›ºå®šæ˜¾ç¤ºï¼Œä¸å¯åˆ é™¤ï¼‰
        // å°NPCï¼šåæ ‡ä¸º2Ã—2æ ¼å­çš„å³ä¸‹è§’åæ ‡
        // NPCå»ºç­‘åæ ‡ï¼ˆä»£ç å†…éƒ¨gameXå¯¹åº”Yè½´å‘å·¦ï¼ŒgameYå¯¹åº”Xè½´å‘ä¸Šï¼‰
        // ç”¨æˆ·åæ ‡(X,Y)è½¬æ¢ä¸ºä»£ç (gameX,gameY)=(Y,X)
        const NPC_BUILDINGS = {
            west:  { name: 'è¥¿', x: 604, y: 593, size: 2, color: 'rgba(128, 128, 128, 0.6)', border: '#666' },  // æ˜¾ç¤º(594,604) èŒƒå›´X:593~594,Y:604~605
            south: { name: 'å—', x: 594, y: 593, size: 2, color: 'rgba(128, 128, 128, 0.6)', border: '#666' },  // æ˜¾ç¤º(594,594) èŒƒå›´X:593~594,Y:594~595
            east:  { name: 'ä¸œ', x: 594, y: 603, size: 2, color: 'rgba(128, 128, 128, 0.6)', border: '#666' },  // æ˜¾ç¤º(604,594) èŒƒå›´X:603~604,Y:594~595
            north: { name: 'åŒ—', x: 604, y: 603, size: 2, color: 'rgba(128, 128, 128, 0.6)', border: '#666' }   // æ˜¾ç¤º(604,604) èŒƒå›´X:603~604,Y:604~605
        };
        
        // ç‹åŸNPCï¼š12Ã—12åŒºåŸŸï¼Œä¸­å¿ƒåæ ‡(599,600)
        // ç”¨æˆ·åæ ‡èŒƒå›´ï¼šX=593~604, Y=594~605
        // ä»£ç åæ ‡(gameX,gameY)=(594,593)ï¼Œåˆšå¥½è¦†ç›–ä¸œå—è¥¿åŒ—å››ä¸ªè§’
        const WANG_CHENG = {
            name: 'ç‹åŸ',
            x: 594,      // ä»£ç gameX (å¯¹åº”ç”¨æˆ·Y_min)
            y: 593,      // ä»£ç gameY (å¯¹åº”ç”¨æˆ·X_min)
            size: 12,    // 12Ã—12
            color: 'rgba(255, 215, 0, 0.15)',  // é‡‘è‰²åŠé€æ˜
            border: 'rgba(255, 215, 0, 0.5)'
        };
        
        // ç‰¹æ®ŠåŒºåŸŸèƒŒæ™¯é…ç½®ï¼ˆä»å¤–åˆ°å†…ç»˜åˆ¶ï¼šæ²ƒåœŸâ†’é»‘åœŸâ†’çº¢åœŸï¼‰
        const SPECIAL_ZONES = [
            {
                name: 'æ²ƒåœŸ',
                x: 450,      // å³ä¸‹è§’x
                y: 450,      // å³ä¸‹è§’y
                size: 300,   // 300Ã—300 (450~749)
                color: 'rgba(144, 238, 144, 0.12)',  // æ·¡ç»¿ç™½è‰²
                border: 'rgba(144, 238, 144, 0.3)'
            },
            {
                name: 'é»‘åœŸ',
                x: 552,      // å³ä¸‹è§’x
                y: 552,      // å³ä¸‹è§’y
                size: 96,    // 96Ã—96 (552~647)
                color: 'rgba(128, 128, 128, 0.15)',  // æ·¡ç°è‰²
                border: 'rgba(128, 128, 128, 0.3)'
            },
            {
                name: 'çº¢åœŸ',
                x: 586,      // å³ä¸‹è§’x
                y: 586,      // å³ä¸‹è§’y
                size: 28,    // 28Ã—28 (586~613)
                color: 'rgba(255, 100, 100, 0.15)',  // æ·¡çº¢è‰²
                border: 'rgba(255, 100, 100, 0.3)'
            }
        ];
        
        // å½“å‰é€‰ä¸­çš„è”ç›Ÿ
        let currentAlliance = 0;
        
        // ç¼“å­˜æ¿€æ´»çš„æ——é›†åˆï¼ˆæŒ‰è”ç›Ÿåˆ†ç»„ï¼‰
        let activeQiSets = {};  // { allianceId: Set }
        
        // çŠ¶æ€
        let currentTool = 'move';  // é»˜è®¤ä¸ºç§»åŠ¨ç”»å¸ƒå·¥å…·
        let buildings = { qi: [], bao: [], keng: [], kuang: [] };
        let panOffset = { x: 0, y: 0 };
        let zoom = 1;
        let rotation = 45;  // é»˜è®¤æ—‹è½¬45åº¦
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let panStart = { x: 0, y: 0 };
        let previewPos = null;
        let hoveredBuilding = null;
        
        // æ°´å°çŠ¶æ€
        let watermarkRemoved = false;
        
        // æ‹–åŠ¨å»ºç­‘çŠ¶æ€
        let selectedBuildings = [];  // é€‰ä¸­çš„å»ºç­‘åˆ—è¡¨ [{type, index, building}]
        let isSelectingArea = false;  // æ˜¯å¦æ­£åœ¨æ¡†é€‰
        let selectionStart = null;    // æ¡†é€‰èµ·ç‚¹
        let selectionEnd = null;      // æ¡†é€‰ç»ˆç‚¹
        let isDraggingBuilding = false;  // æ˜¯å¦æ­£åœ¨æ‹–åŠ¨å»ºç­‘
        let dragBuildingStart = null;    // æ‹–åŠ¨å»ºç­‘çš„èµ·å§‹æ¸¸æˆåæ ‡
        let dragBuildingOffsets = [];    // æ‹–åŠ¨æ—¶å„å»ºç­‘ç›¸å¯¹äºèµ·ç‚¹çš„åç§»
        
        // ç¼“å­˜ï¼ˆæŒ‰è”ç›Ÿåˆ†ç»„ï¼‰
        let qiCoverageByAlliance = {};  // { allianceId: Set }
        let qiForbiddenCenters = new Set();
        let kengCoverage = new Set();
        
        // ========== åˆå§‹åŒ– ==========
        
        function init() {
            initAllianceUI();
            initAllianceStats();
            initZoomButtons();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            bindEvents();
            // è®¾ç½®é»˜è®¤å·¥å…·ä¸ºç§»åŠ¨ç”»å¸ƒ
            selectTool('move');
            // è®¾ç½®é»˜è®¤æ—‹è½¬è§’åº¦
            setRotation(45);
            render();
        }
        
        function initAllianceUI() {
            const grid = document.getElementById('alliance-grid');
            grid.innerHTML = ALLIANCES.map((a, i) => `
                <button class="alliance-btn ${i === 0 ? 'active' : ''}" onclick="selectAlliance(${i})" id="alliance-${i}" style="background: ${a.colorInactive};">
                    <div class="alliance-color" style="background: ${a.color};"></div>
                    <span>${a.name}</span>
                </button>
            `).join('');
        }
        
        function initAllianceStats() {
            const container = document.getElementById('alliance-stats');
            container.innerHTML = ALLIANCES.map(a => `
                <div class="stat-row">
                    <span class="stat-label" style="color: ${a.color};">ğŸš© ${a.name}</span>
                    <span class="stat-value" id="stat-alliance-${a.id}">0/0</span>
                </div>
            `).join('');
        }
        
        function selectAlliance(id) {
            currentAlliance = id;
            document.querySelectorAll('.alliance-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === id);
            });
            // æ›´æ–°æ——æŒ‰é’®çš„é¢œè‰²æç¤º
            const qiBtn = document.getElementById('tool-qi');
            qiBtn.style.background = `linear-gradient(135deg, ${ALLIANCES[id].color}, ${ALLIANCES[id].borderInactive})`;
            render();
        }
        
        function resizeCanvas() {
            canvas.width = canvasWrapper.clientWidth;
            canvas.height = canvasWrapper.clientHeight;
            render();
        }
        
        function bindEvents() {
            // é¼ æ ‡äº‹ä»¶
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            canvas.addEventListener('dblclick', onDblClick);  // åŒå‡»æ”¹åå ¡å’
            
            // è§¦æ‘¸äº‹ä»¶æ”¯æŒï¼ˆæ‰‹æœºç«¯ï¼‰
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });
            // æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', onWheel, { passive: false });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }
        
        // ========== åæ ‡è½¬æ¢ ==========
        
        function screenToGame(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            
            // ç›¸å¯¹äºç”»å¸ƒä¸­å¿ƒ
            let relX = screenX - rect.left - canvas.width / 2;
            let relY = screenY - rect.top - canvas.height / 2;
            
            // é™¤ä»¥ç¼©æ”¾
            relX /= zoom;
            relY /= zoom;
            
            // åå‘æ—‹è½¬
            if (rotation !== 0) {
                const rad = -rotation * Math.PI / 180;
                const newX = relX * Math.cos(rad) - relY * Math.sin(rad);
                const newY = relX * Math.sin(rad) + relY * Math.cos(rad);
                relX = newX;
                relY = newY;
            }
            
            // å‡å»å¹³ç§»
            relX -= panOffset.x;
            relY -= panOffset.y;
            
            // è½¬æ¢ä¸ºæ¸¸æˆåæ ‡
            // æ¸¸æˆåæ ‡ç³»ï¼šå³ä¸‹(0,0)ã€å³ä¸Š(1199,0)ã€å·¦ä¸‹(0,1199)ã€å·¦ä¸Š(1199,1199)
            // Xè½´å‘ä¸Šå¢å¤§ï¼ŒYè½´å‘å·¦å¢å¤§
            // æ³¨ï¼šå†…éƒ¨å˜é‡gameXå®é™…å¯¹åº”Yè½´(å‘å·¦)ï¼ŒgameYå¯¹åº”Xè½´(å‘ä¸Š)
            // ç”»å¸ƒä¸­å¿ƒ = æ¸¸æˆ(600, 600)
            const gameX = 600 - Math.floor(relX / CELL_SIZE);
            const gameY = 600 - Math.floor(relY / CELL_SIZE);
            
            return { x: gameX, y: gameY };
        }
        
        function gameToCanvas(gameX, gameY) {
            // æ¸¸æˆ(600,600) = ç”»å¸ƒä¸­å¿ƒ
            const canvasX = canvas.width / 2 + (600 - gameX) * CELL_SIZE + panOffset.x;
            const canvasY = canvas.height / 2 + (600 - gameY) * CELL_SIZE + panOffset.y;
            return { x: canvasX, y: canvasY };
        }
        
        function isInBounds(gameX, gameY) {
            return gameX >= 0 && gameX <= MAX_COORD && gameY >= 0 && gameY <= MAX_COORD;
        }
        
        function clampCoord(val) {
            return Math.max(0, Math.min(MAX_COORD, val));
        }
        
        function getBuildingDisplayCoord(type, gameX, gameY) {
            const config = BUILDING_CONFIG[type];
            const size = config.size;
            
            if (config.coordType === 'center') {
                // æ——ã€å‘ï¼šæ˜¾ç¤ºä¸­å¿ƒåæ ‡
                return { x: gameX + Math.floor(size / 2), y: gameY + Math.floor(size / 2) };
            } else {
                // å ¡ã€çŸ¿ç­‰2Ã—2å»ºç­‘ï¼šæ˜¾ç¤ºç”¨æˆ·åæ ‡(X_max, Y_min)
                // gameYå¯¹åº”ç”¨æˆ·Xè½´ï¼Œéœ€è¦+size-1æ˜¾ç¤ºæœ€å¤§å€¼
                return { x: gameX, y: gameY + size - 1 };
            }
        }
        
        // ========== é™åˆ¶å¹³ç§»èŒƒå›´ ==========
        
        function clampPanOffset() {
            // è®¡ç®—åœ°å›¾è¾¹ç•Œåœ¨ç”»å¸ƒä¸­çš„ä½ç½®
            // æ¸¸æˆ(0,0)åº”è¯¥åœ¨ç”»å¸ƒå³ä¸‹æ–¹å‘
            // æ¸¸æˆ(1199,1199)åº”è¯¥åœ¨ç”»å¸ƒå·¦ä¸Šæ–¹å‘
            
            // é™åˆ¶ä¸èƒ½æ‹–å‡ºå¤ªè¿œ
            const mapPixelSize = GAME_SIZE * CELL_SIZE; // 12000åƒç´ 
            const maxPan = mapPixelSize / 2; // 6000åƒç´ 
            
            panOffset.x = Math.max(-maxPan, Math.min(maxPan, panOffset.x));
            panOffset.y = Math.max(-maxPan, Math.min(maxPan, panOffset.y));
        }
        
        // ========== äº‹ä»¶å¤„ç† ==========
        
        function onMouseMove(e) {
            const gamePos = screenToGame(e.clientX, e.clientY);
            const inBounds = isInBounds(gamePos.x, gamePos.y);
            
            // æ˜¾ç¤ºåæ ‡ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼Œå³ä½¿è¶…å‡ºèŒƒå›´ï¼‰
            // æ³¨ï¼šgamePos.yå¯¹åº”Xè½´(å‘ä¸Š)ï¼ŒgamePos.xå¯¹åº”Yè½´(å‘å·¦)ï¼Œæ‰€ä»¥æ˜¾ç¤ºæ—¶äº¤æ¢é¡ºåº
            document.getElementById('mouse-game').textContent = `(${gamePos.y}, ${gamePos.x})`;
            
            // è¶…å‡ºè¾¹ç•Œè­¦å‘Š
            boundaryWarning.style.display = inBounds ? 'none' : 'block';
            
            // ç§»åŠ¨ç”»å¸ƒ
            if (currentTool === 'move' && isDragging) {
                let dx = (e.clientX - dragStart.x) / zoom;
                let dy = (e.clientY - dragStart.y) / zoom;
                
                // æ ¹æ®æ—‹è½¬è§’åº¦è°ƒæ•´æ‹–åŠ¨æ–¹å‘
                if (rotation !== 0) {
                    const rad = -rotation * Math.PI / 180;
                    const newDx = dx * Math.cos(rad) - dy * Math.sin(rad);
                    const newDy = dx * Math.sin(rad) + dy * Math.cos(rad);
                    dx = newDx;
                    dy = newDy;
                }
                
                panOffset.x = panStart.x + dx;
                panOffset.y = panStart.y + dy;
                clampPanOffset();
                render();
                return;
            }
            
            // æ‹–åŠ¨å»ºç­‘å·¥å…·
            if (currentTool === 'drag') {
                if (isSelectingArea && selectionStart) {
                    // æ­£åœ¨æ¡†é€‰
                    selectionEnd = { x: gamePos.x, y: gamePos.y };
                    render();
                    return;
                }
                
                if (isDraggingBuilding && dragBuildingStart && selectedBuildings.length > 0) {
                    // æ­£åœ¨æ‹–åŠ¨å»ºç­‘ - å®æ—¶é¢„è§ˆ
                    render();
                    return;
                }
                
                // æ˜¾ç¤ºæç¤ºä¿¡æ¯
                const hoveredB = findBuildingAtPosition(gamePos.x, gamePos.y);
                if (hoveredB) {
                    const isSelected = isBuildingSelected(hoveredB.type, hoveredB.index);
                    const config = BUILDING_CONFIG[hoveredB.type];
                    showTooltip(e.clientX, e.clientY, 
                        `${config.icon} ${config.name}\n${isSelected ? 'âœ… å·²é€‰ä¸­ (æ‹–åŠ¨ç§»åŠ¨)' : 'ç‚¹å‡»é€‰ä¸­ / Ctrl+ç‚¹å‡»å¤šé€‰'}`, 
                        true);
                    hideBuildingInfo();
                } else {
                    if (selectedBuildings.length > 0) {
                        showTooltip(e.clientX, e.clientY, `å·²é€‰ä¸­ ${selectedBuildings.length} ä¸ªå»ºç­‘\næŒ‰ä½æ‹–åŠ¨ / æ¡†é€‰æ·»åŠ `, true);
                    } else {
                        showTooltip(e.clientX, e.clientY, `ç‚¹å‡»é€‰ä¸­å»ºç­‘ / æ¡†é€‰å¤šä¸ª\nCtrl+ç‚¹å‡»å¤šé€‰`, true);
                    }
                    hideBuildingInfo();
                }
                render();
                return;
            }
            
            // å»ºç­‘æ”¾ç½®å·¥å…·
            if (['qi', 'bao', 'keng', 'kuang'].includes(currentTool)) {
                previewPos = alignToGrid(gamePos, currentTool);
                const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                const coord = getBuildingDisplayCoord(currentTool, previewPos.x, previewPos.y);
                const coordNote = BUILDING_CONFIG[currentTool].coordType === 'center' ? 'ä¸­å¿ƒ' : 'å³ä¸‹è§’';
                showTooltip(e.clientX, e.clientY, 
                    `${validation.message}\nåæ ‡(${coordNote}): (${coord.y}, ${coord.x})`, 
                    validation.valid);
                hideBuildingInfo();
                hoveredBuilding = null;
            } else {
                previewPos = null;
                // æŸ¥æ‰¾æ‚¬åœçš„å»ºç­‘ï¼ˆä»…åœ¨éæ”¾ç½®å·¥å…·æ—¶ï¼‰
                hoveredBuilding = findBuildingAt(gamePos.x, gamePos.y);
                
                if (hoveredBuilding) {
                    showBuildingInfo(e.clientX, e.clientY, hoveredBuilding);
                    hideTooltip();
                } else if (currentTool === 'pointer') {
                    hideBuildingInfo();
                    const status = inBounds ? 'æœ‰æ•ˆèŒƒå›´' : 'è¶…å‡ºè¾¹ç•Œ';
                    showTooltip(e.clientX, e.clientY, `åæ ‡: (${gamePos.y}, ${gamePos.x})\n${status}`, inBounds);
                } else {
                    hideBuildingInfo();
                    hideTooltip();
                }
            }
            
            render();
        }
        
        function findBuildingAt(gameX, gameY) {
            // æ£€æµ‹èŒƒå›´ç¨å¾®å®½æ¾ä¸€ç‚¹ï¼Œä½¿ç”¨ <= è€Œä¸æ˜¯ <
            for (const type of ['bao', 'kuang', 'keng', 'qi']) {
                const config = BUILDING_CONFIG[type];
                const size = config.size;
                for (const b of buildings[type]) {
                    // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨å»ºç­‘èŒƒå›´å†…ï¼ˆåŒ…å«è¾¹ç•Œï¼‰
                    if (gameX >= b.x && gameX <= b.x + size - 1 && gameY >= b.y && gameY <= b.y + size - 1) {
                        return { type, building: b };
                    }
                }
            }
            
            // æ£€æŸ¥NPCå»ºç­‘
            for (const [direction, npc] of Object.entries(NPC_BUILDINGS)) {
                if (gameX >= npc.x && gameX <= npc.x + npc.size - 1 && gameY >= npc.y && gameY <= npc.y + npc.size - 1) {
                    return { type: 'npc', building: { x: npc.x, y: npc.y, direction, name: npc.name, size: npc.size } };
                }
            }
            
            // æ£€æŸ¥ç‹åŸ
            if (gameX >= WANG_CHENG.x && gameX <= WANG_CHENG.x + WANG_CHENG.size - 1 && 
                gameY >= WANG_CHENG.y && gameY <= WANG_CHENG.y + WANG_CHENG.size - 1) {
                return { type: 'npc', building: { x: WANG_CHENG.x, y: WANG_CHENG.y, name: WANG_CHENG.name, size: WANG_CHENG.size } };
            }
            
            return null;
        }
        
        function showBuildingInfo(screenX, screenY, info) {
            const statusEl = document.getElementById('building-info-status');
            let borderColor;
            
            // å¤„ç†NPCå»ºç­‘
            if (info.type === 'npc') {
                document.getElementById('building-info-title').innerHTML = `ğŸ›ï¸ NPC-${info.building.name}`;
                
                let npcDisplayX, npcDisplayY;
                if (info.building.size > 2) {
                    // ç‹åŸç­‰å¤§å‹å»ºç­‘ï¼šæ˜¾ç¤ºä¸­å¿ƒåæ ‡
                    npcDisplayX = info.building.y + Math.floor(info.building.size / 2);
                    npcDisplayY = info.building.x + Math.floor(info.building.size / 2);
                } else {
                    // ä¸œå—è¥¿åŒ—ç­‰2Ã—2å»ºç­‘ï¼šæ˜¾ç¤º(X_max, Y_min)
                    npcDisplayX = info.building.y + info.building.size - 1;
                    npcDisplayY = info.building.x;
                }
                document.getElementById('building-info-coord').textContent = `(${npcDisplayX}, ${npcDisplayY})`;
                document.getElementById('building-info-note').textContent = 'å›ºå®šå»ºç­‘';
                statusEl.textContent = 'ä¸å¯åˆ é™¤';
                statusEl.className = 'building-info-status inactive';
                borderColor = '#666';
                
                buildingInfo.style.borderColor = borderColor;
                buildingInfo.style.left = (screenX + 15) + 'px';
                buildingInfo.style.top = (screenY - 10) + 'px';
                buildingInfo.style.display = 'block';
                return;
            }
            
            const config = BUILDING_CONFIG[info.type];
            const coord = getBuildingDisplayCoord(info.type, info.building.x, info.building.y);
            const coordNote = config.coordType === 'center' ? 'ä¸­å¿ƒåæ ‡' : 'å³ä¸‹è§’åæ ‡';
            
            if (info.type === 'qi') {
                const alliance = info.building.alliance;
                const allianceConfig = ALLIANCES[alliance];
                const qKey = `${info.building.x},${info.building.y}`;
                const isActive = activeQiSets[alliance] && activeQiSets[alliance].has(qKey);
                
                document.getElementById('building-info-title').innerHTML = `${config.icon} ${allianceConfig.name}`;
                statusEl.textContent = isActive ? 'âœ“ æ¿€æ´»' : 'âœ— æœªæ¿€æ´»';
                statusEl.className = 'building-info-status ' + (isActive ? 'active' : 'inactive');
                borderColor = isActive ? allianceConfig.borderActive : allianceConfig.borderInactive;
            } else {
                document.getElementById('building-info-title').innerHTML = `${config.icon} ${config.name}`;
                if (info.type === 'bao') {
                    const inQi = isBaoInQi(info.building.x, info.building.y);
                    statusEl.textContent = inQi ? 'âœ“ ç”Ÿæ•ˆä¸­' : 'âœ— æœªç”Ÿæ•ˆ';
                    statusEl.className = 'building-info-status ' + (inQi ? 'active' : 'inactive');
                } else {
                    statusEl.textContent = '';
                }
                borderColor = config.border;
            }
            
            document.getElementById('building-info-coord').textContent = `(${coord.y}, ${coord.x})`;
            document.getElementById('building-info-note').textContent = coordNote;
            
            buildingInfo.style.borderColor = borderColor;
            buildingInfo.style.left = (screenX + 15) + 'px';
            buildingInfo.style.top = (screenY - 10) + 'px';
            buildingInfo.style.display = 'block';
        }
        
        function hideBuildingInfo() { buildingInfo.style.display = 'none'; }
        
        function onMouseDown(e) {
            if (e.button === 2) {
                const gamePos = screenToGame(e.clientX, e.clientY);
                deleteAtPosition(gamePos.x, gamePos.y);
                return;
            }
            
            if (currentTool === 'move') {
                isDragging = true;
                dragStart = { x: e.clientX, y: e.clientY };
                panStart = { x: panOffset.x, y: panOffset.y };
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            if (currentTool === 'drag') {
                const gamePos = screenToGame(e.clientX, e.clientY);
                const clickedBuilding = findBuildingAtPosition(gamePos.x, gamePos.y);
                
                if (clickedBuilding) {
                    // ç‚¹å‡»äº†å»ºç­‘
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl+ç‚¹å‡»ï¼šåˆ‡æ¢é€‰ä¸­çŠ¶æ€
                        toggleBuildingSelection(clickedBuilding.type, clickedBuilding.index, clickedBuilding.building);
                    } else if (isBuildingSelected(clickedBuilding.type, clickedBuilding.index)) {
                        // ç‚¹å‡»å·²é€‰ä¸­çš„å»ºç­‘ï¼šå¼€å§‹æ‹–åŠ¨
                        isDraggingBuilding = true;
                        dragBuildingStart = { x: Math.floor(gamePos.x), y: Math.floor(gamePos.y) };
                        canvas.style.cursor = 'move';
                    } else {
                        // ç‚¹å‡»æœªé€‰ä¸­çš„å»ºç­‘ï¼šæ¸…é™¤æ—§é€‰æ‹©ï¼Œé€‰ä¸­æ–°å»ºç­‘å¹¶å¼€å§‹æ‹–åŠ¨
                        selectedBuildings = [{ type: clickedBuilding.type, index: clickedBuilding.index, building: {...clickedBuilding.building} }];
                        isDraggingBuilding = true;
                        dragBuildingStart = { x: Math.floor(gamePos.x), y: Math.floor(gamePos.y) };
                        canvas.style.cursor = 'move';
                    }
                } else {
                    // ç‚¹å‡»ç©ºç™½å¤„ï¼šå¼€å§‹æ¡†é€‰
                    if (!e.ctrlKey && !e.metaKey) {
                        selectedBuildings = [];
                    }
                    isSelectingArea = true;
                    selectionStart = { x: gamePos.x, y: gamePos.y };
                    selectionEnd = { x: gamePos.x, y: gamePos.y };
                }
                render();
                return;
            }
            
            if (currentTool === 'delete') {
                const gamePos = screenToGame(e.clientX, e.clientY);
                deleteAtPosition(gamePos.x, gamePos.y);
                return;
            }
            
            if (currentTool === 'pointer') return;
            
            if (['qi', 'bao', 'keng', 'kuang'].includes(currentTool) && previewPos) {
                const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                if (validation.valid) {
                    placeBuilding(currentTool, previewPos.x, previewPos.y);
                }
            }
        }
        
        function onMouseUp(e) {
            isDragging = false;
            if (currentTool === 'move') canvas.style.cursor = 'grab';
            
            // å¤„ç†æ‹–åŠ¨å·¥å…·
            if (currentTool === 'drag') {
                if (isSelectingArea && selectionStart && selectionEnd) {
                    // æ¡†é€‰ç»“æŸ
                    const newSelections = getBuildingsInSelectionArea(selectionStart, selectionEnd);
                    if (e && (e.ctrlKey || e.metaKey)) {
                        // Ctrl+æ¡†é€‰ï¼šæ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
                        for (const sel of newSelections) {
                            if (!isBuildingSelected(sel.type, sel.index)) {
                                selectedBuildings.push(sel);
                            }
                        }
                    } else {
                        selectedBuildings = newSelections;
                    }
                    isSelectingArea = false;
                    selectionStart = null;
                    selectionEnd = null;
                    render();
                }
                
                if (isDraggingBuilding && dragBuildingStart && selectedBuildings.length > 0) {
                    // æ‹–åŠ¨ç»“æŸ - è®¡ç®—ä½ç§»å¹¶éªŒè¯
                    const gamePos = screenToGame(e.clientX, e.clientY);
                    const dx = Math.floor(gamePos.x) - dragBuildingStart.x;
                    const dy = Math.floor(gamePos.y) - dragBuildingStart.y;
                    
                    if (dx !== 0 || dy !== 0) {
                        const validation = validateDragPlacement(selectedBuildings, dx, dy);
                        if (validation.valid) {
                            executeDrag(selectedBuildings, dx, dy);
                            showValidationMessage(`âœ… æˆåŠŸç§»åŠ¨ ${selectedBuildings.length} ä¸ªå»ºç­‘`);
                        } else {
                            showValidationMessage(validation.message || 'âŒ æ— æ³•æ”¾ç½®åˆ°è¯¥ä½ç½®');
                        }
                    }
                    
                    isDraggingBuilding = false;
                    dragBuildingStart = null;
                    canvas.style.cursor = 'default';
                    render();
                }
            }
        }
        
        // åŒå‡»æ”¹åå ¡å’
        function onDblClick(e) {
            const gamePos = screenToGame(e.clientX, e.clientY);
            const gameX = Math.floor(gamePos.x);
            const gameY = Math.floor(gamePos.y);
            
            // æŸ¥æ‰¾ç‚¹å‡»ä½ç½®æ˜¯å¦æœ‰å ¡å’
            for (let i = 0; i < buildings.bao.length; i++) {
                const bao = buildings.bao[i];
                if (gameX >= bao.x && gameX < bao.x + 2 && gameY >= bao.y && gameY < bao.y + 2) {
                    // æ‰¾åˆ°å ¡å’ï¼Œå¼¹å‡ºæ”¹åå¯¹è¯æ¡†
                    renameBao(i, bao);
                    return;
                }
            }
        }
        
        // å ¡å’æ”¹åå‡½æ•°
        function renameBao(index, bao) {
            const currentName = bao.name || '';
            // åæ ‡æ˜¾ç¤ºäº¤æ¢ï¼šbao.yå¯¹åº”Xè½´ï¼Œbao.xå¯¹åº”Yè½´
            const newName = prompt(`ğŸ° å ¡å’æ”¹å\nåæ ‡: (${bao.y}, ${bao.x})\nè¯·è¾“å…¥æ–°åç§°ï¼ˆç•™ç©ºåˆ™æ¸…é™¤åç§°ï¼‰:`, currentName);
            
            if (newName !== null) {  // ç”¨æˆ·æ²¡æœ‰ç‚¹å–æ¶ˆ
                buildings.bao[index].name = newName.trim();
                updateStats();
                render();
                if (newName.trim()) {
                    showValidationMessage(`ğŸ° å ¡å’å·²å‘½åä¸º: ${newName.trim()}`);
                } else {
                    showValidationMessage(`ğŸ° å ¡å’åç§°å·²æ¸…é™¤`);
                }
            }
        }
        
        function onMouseLeave() {
            previewPos = null;
            hoveredBuilding = null;
            hideTooltip();
            hideBuildingInfo();
            boundaryWarning.style.display = 'none';
            render();
        }
        
        // ========== è§¦æ‘¸äº‹ä»¶ï¼ˆæ‰‹æœºç«¯ï¼‰==========
        
        let lastTouchDistance = 0;
        let touchStartTime = 0;
        
        function getTouchPos(e) {
            const touch = e.touches[0] || e.changedTouches[0];
            return { clientX: touch.clientX, clientY: touch.clientY };
        }
        
        function onTouchStart(e) {
            e.preventDefault();
            touchStartTime = Date.now();
            
            if (e.touches.length === 2) {
                // ç¦ç”¨åŒæŒ‡ç¼©æ”¾ï¼ˆæ”¹ç”¨æŒ‰é’®æ§åˆ¶ï¼‰
                return;
            }
            
            const pos = getTouchPos(e);
            
            if (currentTool === 'move') {
                isDragging = true;
                dragStart = { x: pos.clientX, y: pos.clientY };
                panStart = { x: panOffset.x, y: panOffset.y };
            } else {
                // æ¨¡æ‹Ÿé¼ æ ‡ç§»åŠ¨æ¥æ›´æ–°é¢„è§ˆ
                onMouseMove({ clientX: pos.clientX, clientY: pos.clientY });
            }
        }
        
        function onTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 2) {
                // ç¦ç”¨åŒæŒ‡ç¼©æ”¾ï¼ˆæ”¹ç”¨æŒ‰é’®æ§åˆ¶ï¼‰
                return;
            }
            
            const pos = getTouchPos(e);
            
            if (currentTool === 'move' && isDragging) {
                let dx = (pos.clientX - dragStart.x) / zoom;
                let dy = (pos.clientY - dragStart.y) / zoom;
                
                // æ ¹æ®æ—‹è½¬è§’åº¦è°ƒæ•´æ‹–åŠ¨æ–¹å‘
                if (rotation !== 0) {
                    const rad = -rotation * Math.PI / 180;
                    const newDx = dx * Math.cos(rad) - dy * Math.sin(rad);
                    const newDy = dx * Math.sin(rad) + dy * Math.cos(rad);
                    dx = newDx;
                    dy = newDy;
                }
                
                panOffset.x = panStart.x + dx;
                panOffset.y = panStart.y + dy;
                clampPanOffset();
                render();
            } else {
                onMouseMove({ clientX: pos.clientX, clientY: pos.clientY });
            }
        }
        
        function onTouchEnd(e) {
            e.preventDefault();
            lastTouchDistance = 0;
            
            const touchDuration = Date.now() - touchStartTime;
            const pos = getTouchPos(e);
            
            if (currentTool === 'move') {
                isDragging = false;
            } else if (touchDuration < 300) {
                // çŸ­æŒ‰è§†ä¸ºç‚¹å‡»ï¼Œæ”¾ç½®å»ºç­‘
                onMouseMove({ clientX: pos.clientX, clientY: pos.clientY });
                if (['qi', 'bao', 'keng', 'kuang'].includes(currentTool) && previewPos) {
                    const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                    if (validation.valid) {
                        placeBuilding(currentTool, previewPos.x, previewPos.y);
                    }
                } else if (currentTool === 'delete') {
                    const gamePos = screenToGame(pos.clientX, pos.clientY);
                    deleteAtPosition(gamePos.x, gamePos.y);
                }
            }
            
            hideTooltip();
            render();
        }
        
        function onWheel(e) {
            e.preventDefault();
            // ä½¿ç”¨ä¹˜æ³•è¿›è¡Œå¹³æ»‘ç¼©æ”¾
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(3, zoom * factor));
            document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
            render();
        }
        
        // ç¼©æ”¾æ§åˆ¶å‡½æ•°
        function zoomIn(e) {
            if (e) { e.preventDefault(); e.stopPropagation(); }
            zoom = Math.min(3, zoom * 1.2);
            document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
            render();
        }
        
        function zoomOut(e) {
            if (e) { e.preventDefault(); e.stopPropagation(); }
            zoom = Math.max(0.1, zoom / 1.2);
            document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
            render();
        }
        
        function zoomReset(e) {
            if (e) { e.preventDefault(); e.stopPropagation(); }
            zoom = 1;
            document.getElementById('zoom-level').textContent = '100%';
            render();
        }
        
        function initZoomButtons() {
            const btnZoomIn = document.getElementById('btn-zoom-in');
            const btnZoomOut = document.getElementById('btn-zoom-out');
            const btnZoomReset = document.getElementById('btn-zoom-reset');
            
            if (btnZoomIn) {
                btnZoomIn.addEventListener('click', zoomIn);
                btnZoomIn.addEventListener('mousedown', e => e.stopPropagation());
                btnZoomIn.addEventListener('mouseup', e => e.stopPropagation());
            }
            if (btnZoomOut) {
                btnZoomOut.addEventListener('click', zoomOut);
                btnZoomOut.addEventListener('mousedown', e => e.stopPropagation());
                btnZoomOut.addEventListener('mouseup', e => e.stopPropagation());
            }
            if (btnZoomReset) {
                btnZoomReset.addEventListener('click', zoomReset);
                btnZoomReset.addEventListener('mousedown', e => e.stopPropagation());
                btnZoomReset.addEventListener('mouseup', e => e.stopPropagation());
            }
        }
        
        function onKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case '1': selectTool('qi'); break;
                case '2': selectTool('bao'); break;
                case '3': selectTool('keng'); break;
                case '4': selectTool('kuang'); break;
                case '5': selectTool('drag'); break;
                case 'p': selectTool('pointer'); break;
                case 'd': selectTool('delete'); break;
                case 'c': centerView(); break;
                case ' ': e.preventDefault(); selectTool('move'); break;
                case 'q': selectAlliance((currentAlliance - 1 + ALLIANCES.length) % ALLIANCES.length); break;
                case 'e': selectAlliance((currentAlliance + 1) % ALLIANCES.length); break;
                case 'escape': 
                    if (currentTool === 'drag') {
                        clearSelection();
                        showValidationMessage('å·²å–æ¶ˆé€‰æ‹©');
                    }
                    break;
            }
        }
        
        function onKeyUp(e) { /* ç©ºæ ¼é”®ä¸å†åˆ‡æ¢å·¥å…· */ }
        
        // ========== æ§åˆ¶ ==========
        
        function centerView() {
            panOffset = { x: 0, y: 0 };
            render();
            showValidationMessage('å·²å›åˆ°ä¸­å¿ƒ (600, 600)');
        }
        
        function setRotation(deg) {
            rotation = parseInt(deg);
            document.getElementById('rotation-slider').value = rotation;
            document.getElementById('rotation-display').textContent = rotation;
            document.querySelectorAll('.rotation-preset').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.textContent) === rotation);
            });
            render();
        }
        
        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const toolBtn = document.getElementById('tool-' + tool);
            if (toolBtn) toolBtn.classList.add('active');
            
            // åˆ‡æ¢å·¥å…·æ—¶æ¸…é™¤é€‰ä¸­çŠ¶æ€
            if (tool !== 'drag') {
                clearSelection();
            }
            
            // è®¾ç½®å…‰æ ‡æ ·å¼
            if (tool === 'move') canvas.style.cursor = 'grab';
            else if (tool === 'delete') canvas.style.cursor = 'not-allowed';
            else if (tool === 'pointer') canvas.style.cursor = 'help';
            else if (tool === 'drag') canvas.style.cursor = 'default';
            else canvas.style.cursor = 'crosshair';
        }
        
        // ========== å»æ°´å°åŠŸèƒ½ ==========
        function removeWatermark() {
            const code = prompt('è¯·è¾“å…¥æˆæƒç ä»¥å»é™¤æ°´å°:');
            if (code === '2607') {
                watermarkRemoved = true;
                document.querySelector('.copyright-watermark').style.display = 'none';
                document.getElementById('btn-remove-watermark').textContent = 'âœ… å·²æˆæƒ';
                document.getElementById('btn-remove-watermark').style.background = '#27ae60';
                document.getElementById('btn-remove-watermark').disabled = true;
                showValidationMessage('ğŸ‰ æ°´å°å·²æˆåŠŸç§»é™¤ï¼');
                render();
            } else if (code !== null) {
                showValidationMessage('âŒ æˆæƒç é”™è¯¯');
            }
        }
        
        // ========== å»ºç­‘é€‰æ‹©ä¸æ‹–åŠ¨ ==========
        
        // æ¸…é™¤é€‰ä¸­çŠ¶æ€
        function clearSelection() {
            selectedBuildings = [];
            isSelectingArea = false;
            selectionStart = null;
            selectionEnd = null;
            isDraggingBuilding = false;
            render();
        }
        
        // æŸ¥æ‰¾æŒ‡å®šä½ç½®çš„å»ºç­‘ï¼ˆè¿”å›typeå’Œindexï¼‰
        function findBuildingAtPosition(gameX, gameY) {
            const gx = Math.floor(gameX);
            const gy = Math.floor(gameY);
            
            // æ£€æŸ¥å„ç±»å‹å»ºç­‘
            for (const type of ['qi', 'bao', 'keng', 'kuang']) {
                const size = BUILDING_CONFIG[type].size;
                for (let i = 0; i < buildings[type].length; i++) {
                    const b = buildings[type][i];
                    if (gx >= b.x && gx < b.x + size && gy >= b.y && gy < b.y + size) {
                        return { type, index: i, building: b };
                    }
                }
            }
            return null;
        }
        
        // æ£€æŸ¥å»ºç­‘æ˜¯å¦å·²è¢«é€‰ä¸­
        function isBuildingSelected(type, index) {
            return selectedBuildings.some(s => s.type === type && s.index === index);
        }
        
        // åˆ‡æ¢å»ºç­‘é€‰ä¸­çŠ¶æ€
        function toggleBuildingSelection(type, index, building) {
            const existingIndex = selectedBuildings.findIndex(s => s.type === type && s.index === index);
            if (existingIndex >= 0) {
                selectedBuildings.splice(existingIndex, 1);
            } else {
                selectedBuildings.push({ type, index, building: {...building} });
            }
            render();
        }
        
        // è·å–æ¡†é€‰åŒºåŸŸå†…çš„æ‰€æœ‰å»ºç­‘
        function getBuildingsInSelectionArea(start, end) {
            const minX = Math.min(start.x, end.x);
            const maxX = Math.max(start.x, end.x);
            const minY = Math.min(start.y, end.y);
            const maxY = Math.max(start.y, end.y);
            
            const result = [];
            for (const type of ['qi', 'bao', 'keng', 'kuang']) {
                const size = BUILDING_CONFIG[type].size;
                for (let i = 0; i < buildings[type].length; i++) {
                    const b = buildings[type][i];
                    // å»ºç­‘ä¸­å¿ƒç‚¹åœ¨æ¡†é€‰åŒºåŸŸå†…
                    const cx = b.x + size / 2;
                    const cy = b.y + size / 2;
                    if (cx >= minX && cx <= maxX && cy >= minY && cy <= maxY) {
                        result.push({ type, index: i, building: {...b} });
                    }
                }
            }
            return result;
        }
        
        // éªŒè¯æ‹–åŠ¨åçš„ä½ç½®æ˜¯å¦åˆæ³•
        function validateDragPlacement(draggedBuildings, dx, dy) {
            // å…ˆä¸´æ—¶ç§»é™¤è¢«æ‹–åŠ¨çš„å»ºç­‘
            const removedBuildings = {};
            for (const sel of draggedBuildings) {
                if (!removedBuildings[sel.type]) removedBuildings[sel.type] = [];
                removedBuildings[sel.type].push(sel.index);
            }
            
            // æš‚å­˜åŸå§‹å»ºç­‘æ•°æ®
            const originalBuildings = JSON.parse(JSON.stringify(buildings));
            
            // ä»æ•°ç»„ä¸­ç§»é™¤ï¼ˆæŒ‰ç´¢å¼•ä»å¤§åˆ°å°æ’åºåç§»é™¤ï¼‰
            for (const type in removedBuildings) {
                removedBuildings[type].sort((a, b) => b - a);
                for (const idx of removedBuildings[type]) {
                    buildings[type].splice(idx, 1);
                }
            }
            
            // é‡å»ºç¼“å­˜
            updateCoverage();
            
            // éªŒè¯æ¯ä¸ªå»ºç­‘çš„æ–°ä½ç½®
            let allValid = true;
            let errorMsg = '';
            for (const sel of draggedBuildings) {
                const newX = sel.building.x + dx;
                const newY = sel.building.y + dy;
                const validation = validatePlacement(sel.type, newX, newY);
                if (!validation.valid) {
                    allValid = false;
                    errorMsg = validation.message;
                    break;
                }
            }
            
            // æ¢å¤åŸå§‹å»ºç­‘æ•°æ®
            buildings = originalBuildings;
            updateCoverage();
            
            return { valid: allValid, message: errorMsg };
        }
        
        // æ‰§è¡Œå»ºç­‘æ‹–åŠ¨
        function executeDrag(draggedBuildings, dx, dy) {
            // æ›´æ–°æ¯ä¸ªè¢«æ‹–åŠ¨å»ºç­‘çš„åæ ‡
            for (const sel of draggedBuildings) {
                buildings[sel.type][sel.index].x += dx;
                buildings[sel.type][sel.index].y += dy;
            }
            
            // æ›´æ–°é€‰ä¸­å»ºç­‘åˆ—è¡¨ä¸­çš„åæ ‡å¼•ç”¨
            for (let i = 0; i < selectedBuildings.length; i++) {
                selectedBuildings[i].building.x += dx;
                selectedBuildings[i].building.y += dy;
            }
            
            updateCoverage();
            updateStats();
            render();
        }
        
        function alignToGrid(pos, type) {
            const size = BUILDING_CONFIG[type].size;
            if (type === 'bao' || type === 'kuang') {
                // å ¡å’ŒçŸ¿ï¼šç›´æ¥ä½¿ç”¨å½“å‰åæ ‡ï¼Œä¸å†å¼ºåˆ¶å¶æ•°å¯¹é½
                // è¿™æ ·å¯ä»¥è´´ç€å‘çš„ä»»æ„è¾¹æ”¾ç½®
                return { x: pos.x, y: pos.y };
            }
            // æ——å’Œå‘ï¼šä»¥ç‚¹å‡»ä½ç½®ä¸ºä¸­å¿ƒæ”¾ç½®
            return { x: pos.x - Math.floor(size / 2), y: pos.y - Math.floor(size / 2) };
        }
        
        // ========== éªŒè¯ ==========
        
        function validatePlacement(type, x, y) {
            const size = BUILDING_CONFIG[type].size;
            
            if (x < 0 || y < 0 || x + size > GAME_SIZE || y + size > GAME_SIZE) {
                return { valid: false, message: 'âŒ è¶…å‡ºåœ°å›¾èŒƒå›´(0-1199)' };
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸NPCå»ºç­‘é‡å 
            if (isOverlapWithNPC(x, y, size)) {
                return { valid: false, message: 'âŒ ä¸èƒ½ä¸NPCå»ºç­‘é‡å ' };
            }
            
            if (type === 'qi') {
                // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰æ——é‡å ï¼ˆå®Œå…¨ç›¸åŒä½ç½®ï¼‰
                for (const q of buildings.qi) {
                    if (q.x === x && q.y === y) return { valid: false, message: 'âŒ ä½ç½®å·²æœ‰æ——' };
                }
                // æ——å¯ä»¥éšæ„æ”¾ç½®ï¼Œä½†æ˜¾ç¤ºæ˜¯å¦æ¿€æ´»
                const allianceName = ALLIANCES[currentAlliance].name;
                const sameAllianceQi = getQiByAlliance(currentAlliance);
                const willBeActive = sameAllianceQi.length === 0 || isAdjacentToExistingQi(x, y, currentAlliance);
                return { valid: true, message: willBeActive ? `âœ“ ${allianceName}ï¼ˆæ¿€æ´»ï¼‰` : `âš  ${allianceName}ï¼ˆæœªæ¿€æ´»ï¼‰` };
            }
            
            if (type === 'bao') {
                for (let dx = 0; dx < size; dx++) {
                    for (let dy = 0; dy < size; dy++) {
                        const key = `${x + dx},${y + dy}`;
                        if (kengCoverage.has(key)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½å»ºåœ¨å‘ä¸Š' };
                        if (qiForbiddenCenters.has(key)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½è¦†ç›–æ——ä¸­å¿ƒ' };
                    }
                }
                for (const b of buildings.bao) { if (isOverlap(x, y, size, b.x, b.y, size)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½é‡å ' }; }
                for (const k of buildings.kuang) { if (isOverlap(x, y, size, k.x, k.y, 2)) return { valid: false, message: 'âŒ å ¡ä¸èƒ½ä¸çŸ¿é‡å ' }; }
                return { valid: true, message: isBaoInQi(x, y) ? 'âœ“ å ¡ï¼ˆç”Ÿæ•ˆï¼‰' : 'âš  å ¡ï¼ˆä¸ç”Ÿæ•ˆï¼‰' };
            }
            
            if (type === 'keng') {
                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å‘é‡å 
                for (const k of buildings.keng) { if (isOverlap(x, y, size, k.x, k.y, 3)) return { valid: false, message: 'âŒ å‘ä¸èƒ½é‡å ' }; }
                // æ£€æŸ¥æ˜¯å¦ä¸å ¡/çŸ¿é‡å 
                for (let dx = 0; dx < size; dx++) {
                    for (let dy = 0; dy < size; dy++) {
                        for (const b of buildings.bao) { if (isOverlap(x + dx, y + dy, 1, b.x, b.y, 2)) return { valid: false, message: 'âŒ å‘ä¸èƒ½ä¸å ¡é‡å ' }; }
                        for (const k of buildings.kuang) { if (isOverlap(x + dx, y + dy, 1, k.x, k.y, 2)) return { valid: false, message: 'âŒ å‘ä¸èƒ½ä¸çŸ¿é‡å ' }; }
                    }
                }
                return { valid: true, message: 'âœ“ å¯ä»¥æ”¾ç½®å‘' };
            }
            
            if (type === 'kuang') {
                for (let dx = 0; dx < size; dx++) {
                    for (let dy = 0; dy < size; dy++) {
                        if (kengCoverage.has(`${x + dx},${y + dy}`)) return { valid: false, message: 'âŒ çŸ¿ä¸èƒ½å»ºåœ¨å‘ä¸Š' };
                    }
                }
                for (const k of buildings.kuang) { if (isOverlap(x, y, size, k.x, k.y, 2)) return { valid: false, message: 'âŒ çŸ¿ä¸èƒ½é‡å ' }; }
                for (const b of buildings.bao) { if (isOverlap(x, y, size, b.x, b.y, 2)) return { valid: false, message: 'âŒ çŸ¿ä¸èƒ½ä¸å ¡é‡å ' }; }
                return { valid: true, message: 'âœ“ å¯ä»¥æ”¾ç½®çŸ¿' };
            }
            
            return { valid: false, message: 'æœªçŸ¥é”™è¯¯' };
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸åŒè”ç›Ÿçš„ç°æœ‰æ——ç›¸é‚»
        function isAdjacentToExistingQi(x, y, alliance = currentAlliance) {
            for (const q of buildings.qi) {
                if (q.alliance === alliance && Math.abs(x - q.x) <= 7 && Math.abs(y - q.y) <= 7) return true;
            }
            return false;
        }
        
        // è·å–æŸè”ç›Ÿçš„æ——
        function getQiByAlliance(alliance) {
            return buildings.qi.filter(q => q.alliance === alliance);
        }
        
        // è·å–æŸè”ç›Ÿæ‰€æœ‰æ¿€æ´»çš„æ——ï¼ˆå½¢æˆè¿é€šåŒºåŸŸçš„æ——ï¼‰
        function getActiveQiSetForAlliance(alliance) {
            const allianceQi = getQiByAlliance(alliance);
            if (allianceQi.length === 0) return new Set();
            if (allianceQi.length === 1) return new Set([`${allianceQi[0].x},${allianceQi[0].y}`]);
            
            // æ‰¾åˆ°æœ€å¤§çš„è¿é€šåˆ†é‡
            const allQi = allianceQi.map(q => ({ x: q.x, y: q.y, key: `${q.x},${q.y}` }));
            const visited = new Set();
            let largestComponent = [];
            
            for (const start of allQi) {
                if (visited.has(start.key)) continue;
                
                const component = [];
                const queue = [start];
                visited.add(start.key);
                component.push(start.key);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    for (const other of allQi) {
                        if (!visited.has(other.key) && Math.abs(current.x - other.x) <= 7 && Math.abs(current.y - other.y) <= 7) {
                            visited.add(other.key);
                            queue.push(other);
                            component.push(other.key);
                        }
                    }
                }
                
                if (component.length > largestComponent.length) {
                    largestComponent = component;
                }
            }
            
            return new Set(largestComponent);
        }
        
        // æ›´æ–°æ‰€æœ‰è”ç›Ÿçš„æ¿€æ´»æ——é›†åˆ
        function updateActiveQiSets() {
            activeQiSets = {};
            for (const alliance of ALLIANCES) {
                activeQiSets[alliance.id] = getActiveQiSetForAlliance(alliance.id);
            }
        }
        
        // æ£€æŸ¥æ——æ˜¯å¦æ¿€æ´»
        function isQiActiveByKey(qKey, alliance) {
            return activeQiSets[alliance] && activeQiSets[alliance].has(qKey);
        }
        
        function isBaoInQi(bx, by) {
            // æ£€æŸ¥å ¡æ˜¯å¦åœ¨ä»»ä½•æ¿€æ´»æ——çš„è¦†ç›–èŒƒå›´å†…
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const key = `${bx + dx},${by + dy}`;
                    // æ£€æŸ¥æ‰€æœ‰è”ç›Ÿçš„è¦†ç›–èŒƒå›´
                    for (const allianceId in qiCoverageByAlliance) {
                        if (qiCoverageByAlliance[allianceId].has(key) && !qiForbiddenCenters.has(key)) return true;
                    }
                }
            }
            return false;
        }
        
        function isOverlap(x1, y1, s1, x2, y2, s2) {
            return x1 < x2 + s2 && x1 + s1 > x2 && y1 < y2 + s2 && y1 + s1 > y2;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸NPCå»ºç­‘é‡å 
        function isOverlapWithNPC(x, y, size) {
            // æ£€æŸ¥å››ä¸ªæ–¹å‘NPC
            for (const npc of Object.values(NPC_BUILDINGS)) {
                if (isOverlap(x, y, size, npc.x, npc.y, npc.size)) {
                    return true;
                }
            }
            // æ£€æŸ¥ç‹åŸ
            if (isOverlap(x, y, size, WANG_CHENG.x, WANG_CHENG.y, WANG_CHENG.size)) {
                return true;
            }
            return false;
        }
        
        // ========== æ“ä½œ ==========
        
        // è·å–æŸè”ç›Ÿå ¡çš„ä¸‹ä¸€ä¸ªåºå·
        function getNextBaoIndex(alliance) {
            const baosOfAlliance = buildings.bao.filter(b => b.alliance === alliance);
            return baosOfAlliance.length + 1;
        }
        
        // åˆ¤æ–­å ¡æ‰€å±çš„è”ç›Ÿï¼ˆé€šè¿‡å®ƒåœ¨å“ªä¸ªè”ç›Ÿçš„æ——è¦†ç›–èŒƒå›´å†…ï¼‰
        function getBaoAlliance(bx, by) {
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const key = `${bx + dx},${by + dy}`;
                    for (const allianceId in qiCoverageByAlliance) {
                        if (qiCoverageByAlliance[allianceId].has(key) && !qiForbiddenCenters.has(key)) {
                            return parseInt(allianceId);
                        }
                    }
                }
            }
            return null; // ä¸åœ¨ä»»ä½•æ——ä¸Š
        }
        
        function placeBuilding(type, x, y) {
            if (type === 'qi') {
                buildings[type].push({ x, y, alliance: currentAlliance });
            } else if (type === 'bao') {
                // å ¡æœ‰è”ç›Ÿå½’å±å’Œåºå·
                const alliance = getBaoAlliance(x, y);
                const index = alliance !== null ? getNextBaoIndex(alliance) : null;
                buildings[type].push({ x, y, alliance, index, name: '' });
            } else {
                buildings[type].push({ x, y });
            }
            updateCoverage();
            updateStats();
            render();
            const coord = getBuildingDisplayCoord(type, x, y);
            showValidationMessage(`${BUILDING_CONFIG[type].icon} â†’ (${coord.y}, ${coord.x})`);
        }
        
        function deleteAtPosition(gameX, gameY) {
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†NPCå»ºç­‘
            for (const [direction, npc] of Object.entries(NPC_BUILDINGS)) {
                if (gameX >= npc.x && gameX < npc.x + npc.size && gameY >= npc.y && gameY < npc.y + npc.size) {
                    showValidationMessage(`ğŸ›ï¸ NPC-${npc.name} ä¸å¯åˆ é™¤`);
                    return;
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç‹åŸ
            if (gameX >= WANG_CHENG.x && gameX < WANG_CHENG.x + WANG_CHENG.size && 
                gameY >= WANG_CHENG.y && gameY < WANG_CHENG.y + WANG_CHENG.size) {
                showValidationMessage(`ğŸ›ï¸ ${WANG_CHENG.name} ä¸å¯åˆ é™¤`);
                return;
            }
            
            for (const type of ['bao', 'kuang', 'keng', 'qi']) {
                const size = BUILDING_CONFIG[type].size;
                for (let i = buildings[type].length - 1; i >= 0; i--) {
                    const b = buildings[type][i];
                    if (gameX >= b.x && gameX < b.x + size && gameY >= b.y && gameY < b.y + size) {
                        const coord = getBuildingDisplayCoord(type, b.x, b.y);
                        buildings[type].splice(i, 1);
                        updateCoverage(); updateStats(); render();
                        showValidationMessage(`åˆ é™¤ ${BUILDING_CONFIG[type].icon} (${coord.y}, ${coord.x})`);
                        return;
                    }
                }
            }
        }
        
        function updateCoverage() {
            qiCoverageByAlliance = {};
            qiForbiddenCenters = new Set();
            kengCoverage = new Set();
            
            // æ›´æ–°æ‰€æœ‰è”ç›Ÿçš„æ¿€æ´»æ——é›†åˆ
            updateActiveQiSets();
            
            // æŒ‰è”ç›Ÿè®¡ç®—è¦†ç›–èŒƒå›´ï¼ˆåªæœ‰æ¿€æ´»çš„æ——æ‰æä¾›è¦†ç›–ï¼‰
            for (const alliance of ALLIANCES) {
                qiCoverageByAlliance[alliance.id] = new Set();
            }
            
            for (const q of buildings.qi) {
                const qKey = `${q.x},${q.y}`;
                const alliance = q.alliance;
                if (activeQiSets[alliance] && activeQiSets[alliance].has(qKey)) {
                    for (let dx = 0; dx < 7; dx++) {
                        for (let dy = 0; dy < 7; dy++) {
                            qiCoverageByAlliance[alliance].add(`${q.x + dx},${q.y + dy}`);
                        }
                    }
                }
                qiForbiddenCenters.add(`${q.x + 3},${q.y + 3}`);
            }
            
            for (const k of buildings.keng) {
                for (let dx = 0; dx < 3; dx++) for (let dy = 0; dy < 3; dy++) kengCoverage.add(`${k.x + dx},${k.y + dy}`);
            }
        }
        
        function autoFillBao() {
            if (buildings.qi.length === 0) { showValidationMessage('è¯·å…ˆæ”¾ç½®æ——'); return; }
            let kengCenter = buildings.keng.length > 0 ? { x: buildings.keng[0].x + 1.5, y: buildings.keng[0].y + 1.5 } : { x: 600, y: 600 };
            const candidates = [], checked = new Set();
            // åˆå¹¶æ‰€æœ‰è”ç›Ÿçš„è¦†ç›–èŒƒå›´
            const allCoverage = new Set();
            for (const allianceId in qiCoverageByAlliance) {
                for (const key of qiCoverageByAlliance[allianceId]) {
                    allCoverage.add(key);
                }
            }
            for (const key of allCoverage) {
                const [ax, ay] = key.split(',').map(Number);
                const bx = Math.floor(ax / 2) * 2, by = Math.floor(ay / 2) * 2;
                for (let ox = -2; ox <= 2; ox += 2) {
                    for (let oy = -2; oy <= 2; oy += 2) {
                        const x = bx + ox, y = by + oy, posKey = `${x},${y}`;
                        if (!checked.has(posKey)) {
                            checked.add(posKey);
                            if (validatePlacement('bao', x, y).valid && isBaoInQi(x, y)) {
                                candidates.push({ x, y, dist: Math.hypot(x + 1 - kengCenter.x, y + 1 - kengCenter.y) });
                            }
                        }
                    }
                }
            }
            candidates.sort((a, b) => a.dist - b.dist);
            let placed = 0;
            for (const pos of candidates) {
                if (validatePlacement('bao', pos.x, pos.y).valid) { 
                    const alliance = getBaoAlliance(pos.x, pos.y);
                    const index = alliance !== null ? getNextBaoIndex(alliance) : null;
                    buildings.bao.push({ x: pos.x, y: pos.y, alliance, index, name: '' }); 
                    placed++; 
                }
            }
            updateCoverage(); updateStats(); render();
            showValidationMessage(`è‡ªåŠ¨å¡«å……äº† ${placed} ä¸ªå ¡`);
        }
        
        // ========== æ¸²æŸ“ ==========
        
        function render() {
            ctx.save();
            ctx.fillStyle = '#F0F8FF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            drawGrid();
            drawSpecialZones();  // ç»˜åˆ¶ç‰¹æ®ŠåŒºåŸŸèƒŒæ™¯ï¼ˆæ²ƒåœŸâ†’é»‘åœŸâ†’çº¢åœŸï¼‰
            drawBoundary();
            
            // ç»˜åˆ¶NPCå»ºç­‘ï¼ˆå›ºå®šæ˜¾ç¤ºï¼‰
            drawNPCBuildings();
            
            buildings.qi.forEach(b => drawBuilding('qi', b));
            buildings.keng.forEach(b => drawBuilding('keng', b));
            buildings.kuang.forEach(b => drawBuilding('kuang', b));
            buildings.bao.forEach(b => drawBuilding('bao', b));
            
            // ç»˜åˆ¶ç”»å¸ƒå†…æ°´å°
            drawCanvasWatermark();
            
            if (previewPos && ['qi', 'bao', 'keng', 'kuang'].includes(currentTool)) {
                const validation = validatePlacement(currentTool, previewPos.x, previewPos.y);
                drawPreview(currentTool, previewPos.x, previewPos.y, validation.valid);
            }
            
            if (hoveredBuilding) drawBuildingHighlight(hoveredBuilding.type, hoveredBuilding.building.x, hoveredBuilding.building.y, hoveredBuilding.building);
            
            // ç»˜åˆ¶é€‰ä¸­å»ºç­‘é«˜äº®
            drawSelectedBuildings();
            
            // ç»˜åˆ¶æ¡†é€‰åŒºåŸŸ
            drawSelectionArea();
            
            // ç»˜åˆ¶æ‹–åŠ¨é¢„è§ˆ
            drawDragPreview();
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶é€‰ä¸­çš„å»ºç­‘é«˜äº®
        function drawSelectedBuildings() {
            if (selectedBuildings.length === 0) return;
            
            for (const sel of selectedBuildings) {
                const size = BUILDING_CONFIG[sel.type].size;
                const pos = gameToCanvas(sel.building.x, sel.building.y);
                const pSize = size * CELL_SIZE;
                
                // ç»˜åˆ¶é€‰ä¸­è¾¹æ¡†
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.strokeRect(pos.x - pSize - 1, pos.y - pSize - 1, pSize + 2, pSize + 2);
                
                // ç»˜åˆ¶é€‰ä¸­è§’æ ‡
                ctx.fillStyle = '#00d4ff';
                const cornerSize = 6;
                ctx.fillRect(pos.x - pSize - 1, pos.y - pSize - 1, cornerSize, cornerSize);
                ctx.fillRect(pos.x - cornerSize + 1, pos.y - pSize - 1, cornerSize, cornerSize);
                ctx.fillRect(pos.x - pSize - 1, pos.y - cornerSize + 1, cornerSize, cornerSize);
                ctx.fillRect(pos.x - cornerSize + 1, pos.y - cornerSize + 1, cornerSize, cornerSize);
            }
        }
        
        // ç»˜åˆ¶æ¡†é€‰åŒºåŸŸ
        function drawSelectionArea() {
            if (!isSelectingArea || !selectionStart || !selectionEnd) return;
            
            const startPos = gameToCanvas(selectionStart.x, selectionStart.y);
            const endPos = gameToCanvas(selectionEnd.x, selectionEnd.y);
            
            const x = Math.min(startPos.x, endPos.x);
            const y = Math.min(startPos.y, endPos.y);
            const w = Math.abs(endPos.x - startPos.x);
            const h = Math.abs(endPos.y - startPos.y);
            
            // åŠé€æ˜å¡«å……
            ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
            ctx.fillRect(x, y, w, h);
            
            // è™šçº¿è¾¹æ¡†
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.strokeRect(x, y, w, h);
            ctx.setLineDash([]);
        }
        
        // ç»˜åˆ¶æ‹–åŠ¨é¢„è§ˆ
        function drawDragPreview() {
            if (!isDraggingBuilding || !dragBuildingStart || selectedBuildings.length === 0) return;
            
            // è·å–å½“å‰é¼ æ ‡ä½ç½®å¹¶è®¡ç®—åç§»
            const rect = canvas.getBoundingClientRect();
            // è¿™é‡Œæ— æ³•ç›´æ¥è·å–é¼ æ ‡ä½ç½®ï¼Œéœ€è¦åœ¨mousemoveæ—¶è®°å½•
        }
        
        function drawCanvasWatermark() {
            // å¦‚æœæ°´å°å·²è¢«ç§»é™¤ï¼Œåˆ™ä¸ç»˜åˆ¶
            if (watermarkRemoved) return;
            
            // åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶åŠé€æ˜æ°´å°
            ctx.save();
            ctx.globalAlpha = 0.06;
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = '#2980b9';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // åœ¨å¤šä¸ªä½ç½®ç»˜åˆ¶æ°´å°
            const positions = [
                { x: canvas.width * 0.25, y: canvas.height * 0.3 },
                { x: canvas.width * 0.75, y: canvas.height * 0.3 },
                { x: canvas.width * 0.5, y: canvas.height * 0.6 },
                { x: canvas.width * 0.25, y: canvas.height * 0.8 },
                { x: canvas.width * 0.75, y: canvas.height * 0.8 }
            ];
            
            positions.forEach(pos => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(-15 * Math.PI / 180);
                ctx.fillText('2607å…¨æ°‘ä»£è¡¨å¤§ä¼š', 0, 0);
                ctx.restore();
            });
            
            ctx.restore();
        }
        
        function drawGrid() {
            const centerCanvasX = canvas.width / 2 + panOffset.x;
            const centerCanvasY = canvas.height / 2 + panOffset.y;
            
            // è®¡ç®—éœ€è¦ç»˜åˆ¶çš„ç½‘æ ¼èŒƒå›´ï¼ˆè¶³å¤Ÿå¤§ä»¥è¦†ç›–ç¼©æ”¾å’Œå¹³ç§»ï¼‰
            const viewSize = Math.max(canvas.width, canvas.height) / zoom;
            const gridRange = Math.ceil(viewSize / CELL_SIZE) + 50;
            
            // ç»˜åˆ¶ç½‘æ ¼
            for (let i = -gridRange; i <= gridRange; i++) {
                const x = centerCanvasX + i * CELL_SIZE;
                const y = centerCanvasY + i * CELL_SIZE;
                
                // æ¯10æ ¼åŠ ç²—
                if (i % 10 === 0) {
                    ctx.strokeStyle = '#A8C8D8';
                    ctx.lineWidth = 1;
                } else {
                    ctx.strokeStyle = '#C8E0EC';
                    ctx.lineWidth = 0.5;
                }
                
                ctx.beginPath();
                ctx.moveTo(x, centerCanvasY - gridRange * CELL_SIZE);
                ctx.lineTo(x, centerCanvasY + gridRange * CELL_SIZE);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerCanvasX - gridRange * CELL_SIZE, y);
                ctx.lineTo(centerCanvasX + gridRange * CELL_SIZE, y);
                ctx.stroke();
            }
            
            // ä¸­å¿ƒç‚¹æ ‡è®°
            ctx.fillStyle = 'rgba(41, 128, 185, 0.4)';
            ctx.beginPath();
            ctx.arc(centerCanvasX, centerCanvasY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#00d4ff';
            ctx.textAlign = 'left';
            ctx.fillText('', centerCanvasX + 12, centerCanvasY - 5);
        }
        
        // ç»˜åˆ¶ç‰¹æ®ŠåŒºåŸŸèƒŒæ™¯ï¼ˆæ²ƒåœŸâ†’é»‘åœŸâ†’çº¢åœŸï¼Œä»å¤–åˆ°å†…ï¼‰
        function drawSpecialZones() {
            for (const zone of SPECIAL_ZONES) {
                const pos = gameToCanvas(zone.x, zone.y);
                const zoneSize = zone.size * CELL_SIZE;
                const drawX = pos.x - zoneSize;
                const drawY = pos.y - zoneSize;
                
                // ç»˜åˆ¶åŒºåŸŸèƒŒæ™¯
                ctx.fillStyle = zone.color;
                ctx.fillRect(drawX, drawY, zoneSize, zoneSize);
                
                // ç»˜åˆ¶åŒºåŸŸè¾¹æ¡†
                ctx.strokeStyle = zone.border;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.strokeRect(drawX + 0.5, drawY + 0.5, zoneSize - 1, zoneSize - 1);
                ctx.setLineDash([]);
                
                // ç»˜åˆ¶åŒºåŸŸåç§°ï¼ˆå°å­—ä½“ï¼Œåœ¨å³ä¸Šè§’ï¼‰
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = zone.border;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';
                ctx.fillText(zone.name, drawX + zoneSize - 5, drawY + 5);
            }
        }
        
        function drawBoundary() {
            // ç»˜åˆ¶åœ°å›¾è¾¹ç•Œ (0-1199)
            const topLeft = gameToCanvas(1199, 1199);
            const bottomRight = gameToCanvas(0, 0);
            
            // å› ä¸ºæ¸¸æˆåæ ‡Yå‘ä¸Šå¢å¤§ï¼Œç”»å¸ƒYå‘ä¸‹å¢å¤§
            // topLeft åœ¨ç”»å¸ƒä¸Šæ–¹ï¼ŒbottomRight åœ¨ç”»å¸ƒä¸‹æ–¹
            const x = topLeft.x - GAME_SIZE * CELL_SIZE;
            const y = topLeft.y - GAME_SIZE * CELL_SIZE;
            const w = GAME_SIZE * CELL_SIZE;
            const h = GAME_SIZE * CELL_SIZE;
            
            // è¾¹ç•Œæ¡†
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(x, y, w, h);
            ctx.setLineDash([]);
            
            // å››è§’æ ‡ç­¾ (Xè½´å‘ä¸Šå¢å¤§ï¼ŒYè½´å‘å·¦å¢å¤§)
            ctx.font = '11px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            
            // å·¦ä¸Šè§’ (1199, 1199) - Xå¤§=ä¸Šï¼ŒYå¤§=å·¦
            ctx.textAlign = 'left';
            ctx.fillText('(1199, 1199)', x + 5, y + 15);
            
            // å³ä¸‹è§’ (0, 0) - Xå°=ä¸‹ï¼ŒYå°=å³
            ctx.textAlign = 'right';
            ctx.fillText('(0, 0)', x + w - 5, y + h - 5);
            
            // å³ä¸Šè§’ (1199, 0) - Xå¤§=ä¸Šï¼ŒYå°=å³
            ctx.textAlign = 'right';
            ctx.fillText('(1199, 0)', x + w - 5, y + 15);
            
            // å·¦ä¸‹è§’ (0, 1199) - Xå°=ä¸‹ï¼ŒYå¤§=å·¦
            ctx.textAlign = 'left';
            ctx.fillText('(0, 1199)', x + 5, y + h - 5);
        }
        
        function drawNPCBuildings() {
            // å…ˆç»˜åˆ¶ç‹åŸï¼ˆåº•å±‚ï¼‰
            const wcPos = gameToCanvas(WANG_CHENG.x, WANG_CHENG.y);
            const wcSize = WANG_CHENG.size * CELL_SIZE;
            const wcDrawX = wcPos.x - wcSize;
            const wcDrawY = wcPos.y - wcSize;
            
            // ç‹åŸå¡«å……
            ctx.fillStyle = WANG_CHENG.color;
            ctx.fillRect(wcDrawX, wcDrawY, wcSize, wcSize);
            
            // ç‹åŸè¾¹æ¡†
            ctx.strokeStyle = WANG_CHENG.border;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.strokeRect(wcDrawX + 0.5, wcDrawY + 0.5, wcSize - 1, wcSize - 1);
            ctx.setLineDash([]);
            
            // ç‹åŸåç§°
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = 'rgba(255, 215, 0, 1)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(WANG_CHENG.name, wcDrawX + wcSize / 2, wcDrawY + wcSize / 2);
            
            // ç»˜åˆ¶å››ä¸ªæ–¹å‘çš„NPCå»ºç­‘ï¼ˆæ¯ä¸ªæ˜¯ä¸€ä¸ª2Ã—2æ ¼å­ï¼‰
            for (const [direction, npc] of Object.entries(NPC_BUILDINGS)) {
                const pos = gameToCanvas(npc.x, npc.y);
                const pSize = npc.size * CELL_SIZE;
                const drawX = pos.x - pSize;
                const drawY = pos.y - pSize;
                
                // å¡«å……
                ctx.fillStyle = npc.color;
                ctx.fillRect(drawX, drawY, pSize, pSize);
                
                // è¾¹æ¡†
                ctx.strokeStyle = npc.border;
                ctx.lineWidth = 2;
                ctx.strokeRect(drawX + 0.5, drawY + 0.5, pSize - 1, pSize - 1);
                
                // åœ¨æ ¼å­ä¸­å¿ƒç»˜åˆ¶æ–¹å‘åç§°
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(npc.name, drawX + pSize / 2, drawY + pSize / 2);
            }
        }
        
        function drawBuilding(type, building) {
            const gameX = building.x;
            const gameY = building.y;
            const config = BUILDING_CONFIG[type];
            const size = config.size;
            const pos = gameToCanvas(gameX, gameY);
            const pSize = size * CELL_SIZE;
            const drawX = pos.x - pSize;
            const drawY = pos.y - pSize;
            
            // ç¡®å®šå¡«å……é¢œè‰²
            let fillColor, borderColor;
            if (type === 'qi') {
                const qKey = `${gameX},${gameY}`;
                const alliance = building.alliance;
                const allianceConfig = ALLIANCES[alliance];
                const isActive = activeQiSets[alliance] && activeQiSets[alliance].has(qKey);
                fillColor = isActive ? allianceConfig.colorActive : allianceConfig.colorInactive;
                borderColor = isActive ? allianceConfig.borderActive : allianceConfig.borderInactive;
            } else if (type === 'bao') {
                fillColor = isBaoInQi(gameX, gameY) ? config.colorActive : config.colorInactive;
                borderColor = config.border;
            } else {
                fillColor = config.color;
                borderColor = config.border;
            }
            
            ctx.fillStyle = fillColor;
            ctx.fillRect(drawX, drawY, pSize, pSize);
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = type === 'qi' ? 2 : 1;
            ctx.strokeRect(drawX + 0.5, drawY + 0.5, pSize - 1, pSize - 1);
            
            if (type === 'qi') {
                const centerPos = gameToCanvas(gameX + 3, gameY + 3);
                const cx = centerPos.x - CELL_SIZE, cy = centerPos.y - CELL_SIZE;
                ctx.fillStyle = '#E8F0F5';
                ctx.fillRect(cx, cy, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx + 2, cy + 2); ctx.lineTo(cx + CELL_SIZE - 2, cy + CELL_SIZE - 2);
                ctx.moveTo(cx + CELL_SIZE - 2, cy + 2); ctx.lineTo(cx + 2, cy + CELL_SIZE - 2);
                ctx.stroke();
            }
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (type === 'keng') { 
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#fff'; 
                ctx.fillText('å‘', drawX + pSize/2, drawY + pSize/2); 
            }
            if (type === 'kuang') { 
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#333'; 
                ctx.fillText('çŸ¿', drawX + pSize/2, drawY + pSize/2); 
            }
            if (type === 'bao') {
                // è·å–åæ ‡
                const coord = getBuildingDisplayCoord('bao', building.x, building.y);
                const hasIndex = building.index !== null && building.index !== undefined;
                const hasName = building.name && building.name.trim();
                
                // æ ¹æ®è”ç›Ÿè·å–é¢œè‰²
                const allianceColor = building.alliance !== null && building.alliance !== undefined 
                    ? ALLIANCES[building.alliance].borderActive 
                    : '#888';
                
                // å¤šè¡Œæ˜¾ç¤ºï¼šåºå·ã€åç§°ã€åæ ‡
                const centerX = drawX + pSize / 2;
                const lineHeight = pSize / 4; // æ¯è¡Œé«˜åº¦
                
                if (hasIndex || hasName) {
                    // ç¬¬ä¸€è¡Œï¼šåºå·
                    if (hasIndex) {
                        ctx.font = 'bold 8px Arial';
                        ctx.fillStyle = allianceColor;
                        ctx.fillText(building.index.toString(), centerX, drawY + lineHeight * 0.9);
                    }
                    
                    // ç¬¬äºŒè¡Œï¼šåç§°ï¼ˆæˆªæ–­æ˜¾ç¤ºï¼Œæœ€å¤š4å­—ç¬¦ï¼‰
                    if (hasName) {
                        let displayName = building.name;
                        if (displayName.length > 4) {
                            displayName = displayName.substring(0, 3) + 'â€¦';
                        }
                        ctx.font = 'bold 7px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.fillText(displayName, centerX, drawY + lineHeight * 2);
                    }
                    
                    // ç¬¬ä¸‰è¡Œï¼šåæ ‡
                    ctx.font = '5px Arial';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(`${coord.y},${coord.x}`, centerX, drawY + lineHeight * 3.1);
                } else {
                    // æ— åºå·æ—¶åªæ˜¾ç¤ºåæ ‡
                    ctx.font = '6px Arial';
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillText(`${coord.y},${coord.x}`, centerX, drawY + pSize / 2);
                }
            }
        }
        
        function drawBuildingHighlight(type, gameX, gameY, buildingData) {
            // è·å–å»ºç­‘å°ºå¯¸
            let size;
            if (type === 'npc') {
                // NPCå»ºç­‘çš„å°ºå¯¸ä»buildingDataä¸­è·å–
                size = buildingData && buildingData.size ? buildingData.size : 2;
            } else if (BUILDING_CONFIG[type]) {
                size = BUILDING_CONFIG[type].size;
            } else {
                return; // æœªçŸ¥ç±»å‹ï¼Œä¸ç»˜åˆ¶
            }
            
            const pos = gameToCanvas(gameX, gameY);
            const pSize = size * CELL_SIZE;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            ctx.strokeRect(pos.x - pSize - 2, pos.y - pSize - 2, pSize + 4, pSize + 4);
            ctx.setLineDash([]);
        }
        
        function drawPreview(type, gameX, gameY, valid) {
            const size = BUILDING_CONFIG[type].size;
            const config = BUILDING_CONFIG[type];
            const pos = gameToCanvas(gameX, gameY);
            const pSize = size * CELL_SIZE;
            const drawX = pos.x - pSize, drawY = pos.y - pSize;
            
            // ç¡®å®šé¢„è§ˆé¢œè‰²
            let previewColor;
            if (!valid) {
                previewColor = 'rgba(255,0,0,0.4)';
            } else if (type === 'qi') {
                const allianceConfig = ALLIANCES[currentAlliance];
                const sameAllianceQi = getQiByAlliance(currentAlliance);
                const willBeActive = sameAllianceQi.length === 0 || isAdjacentToExistingQi(gameX, gameY, currentAlliance);
                previewColor = willBeActive ? allianceConfig.colorActive : allianceConfig.colorInactive;
            } else if (type === 'bao') {
                previewColor = isBaoInQi(gameX, gameY) ? config.colorActive : config.colorInactive;
            } else {
                previewColor = config.color || config.colorActive;
            }
            
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = previewColor;
            ctx.fillRect(drawX, drawY, pSize, pSize);
            ctx.strokeStyle = valid ? '#fff' : '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.strokeRect(drawX, drawY, pSize, pSize);
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
        }
        
        // ========== UI ==========
        
        function showTooltip(x, y, message, valid) {
            tooltip.innerHTML = message.replace(/\n/g, '<br>');
            tooltip.className = 'tooltip ' + (valid ? 'success' : 'error');
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() { tooltip.style.display = 'none'; }
        function showValidationMessage(msg) { document.getElementById('validation-msg').textContent = msg; }
        
        function updateStats() {
            // æŒ‰è”ç›Ÿç»Ÿè®¡æ——çš„æ•°é‡
            for (const alliance of ALLIANCES) {
                const allianceQi = getQiByAlliance(alliance.id);
                const activeCount = activeQiSets[alliance.id] ? activeQiSets[alliance.id].size : 0;
                const totalCount = allianceQi.length;
                const el = document.getElementById(`stat-alliance-${alliance.id}`);
                if (el) {
                    el.textContent = `${activeCount}/${totalCount}`;
                    el.className = 'stat-value ' + (activeCount === totalCount && totalCount > 0 ? 'success' : totalCount > 0 ? 'warning' : '');
                }
            }
            
            // ç»Ÿè®¡å‘å’ŒçŸ¿
            document.getElementById('stat-keng').textContent = buildings.keng.length;
            document.getElementById('stat-kuang').textContent = buildings.kuang.length;
            
            // ç»Ÿè®¡å ¡çš„ç”Ÿæ•ˆ/æœªç”Ÿæ•ˆæ•°é‡
            let baoActiveCount = 0, baoInactiveCount = 0;
            for (const b of buildings.bao) { 
                if (isBaoInQi(b.x, b.y)) baoActiveCount++; 
                else baoInactiveCount++; 
            }
            document.getElementById('stat-bao-active').textContent = baoActiveCount;
            document.getElementById('stat-bao-inactive').textContent = baoInactiveCount;
        }
        
        function clearAll() {
            if (confirm('ç¡®å®šæ¸…ç©ºï¼Ÿ')) {
                buildings = { qi: [], bao: [], keng: [], kuang: [] };
                updateCoverage(); updateStats(); render();
                showValidationMessage('å·²æ¸…ç©º');
            }
        }
        
        function exportLayout() {
            const exportData = { rotation, alliances: ALLIANCES.map(a => a.name), buildings: {} };
            for (const type of ['qi', 'bao', 'keng', 'kuang']) {
                exportData.buildings[type] = buildings[type].map(b => {
                    const coord = getBuildingDisplayCoord(type, b.x, b.y);
                    // äº¤æ¢åæ ‡ï¼šå†…éƒ¨yå¯¹åº”æ˜¾ç¤ºXï¼Œå†…éƒ¨xå¯¹åº”æ˜¾ç¤ºY
                    const data = { gameX: b.y, gameY: b.x, displayX: coord.y, displayY: coord.x };
                    if (type === 'qi') {
                        data.alliance = b.alliance;
                        data.allianceName = ALLIANCES[b.alliance].name;
                    }
                    if (type === 'bao') {
                        data.alliance = b.alliance;
                        data.index = b.index;
                        data.name = b.name || '';
                    }
                    return data;
                });
            }
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'layout-' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
            showValidationMessage('å·²å¯¼å‡º');
        }
        
        // ========== å¯¼å…¥å¸ƒå±€ ==========
        function importLayout() {
            document.getElementById('import-file').click();
        }
        
        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // æ¸…ç©ºç°æœ‰å»ºç­‘
                    buildings = { qi: [], bao: [], keng: [], kuang: [] };
                    
                    // å¯¼å…¥æ——
                    if (data.buildings && data.buildings.qi) {
                        buildings.qi = data.buildings.qi.map(b => ({
                            x: b.gameX,
                            y: b.gameY,
                            alliance: b.alliance || 0
                        }));
                    }
                    
                    // å¯¼å…¥å ¡ï¼ˆåŒ…å«åºå·å’Œåç§°ï¼‰
                    if (data.buildings && data.buildings.bao) {
                        buildings.bao = data.buildings.bao.map(b => ({
                            x: b.gameX,
                            y: b.gameY,
                            alliance: b.alliance !== undefined ? b.alliance : null,
                            index: b.index || null,
                            name: b.name || ''
                        }));
                    }
                    
                    // å¯¼å…¥å‘
                    if (data.buildings && data.buildings.keng) {
                        buildings.keng = data.buildings.keng.map(b => ({
                            x: b.gameX,
                            y: b.gameY
                        }));
                    }
                    
                    // å¯¼å…¥çŸ¿
                    if (data.buildings && data.buildings.kuang) {
                        buildings.kuang = data.buildings.kuang.map(b => ({
                            x: b.gameX,
                            y: b.gameY
                        }));
                    }
                    
                    // å¯¼å…¥æ—‹è½¬è§’åº¦
                    if (data.rotation !== undefined) {
                        rotation = data.rotation;
                        document.getElementById('rotation-slider').value = rotation;
                        document.getElementById('rotation-value').textContent = rotation + 'Â°';
                    }
                    
                    updateCoverage();
                    updateStats();
                    render();
                    showValidationMessage(`å·²å¯¼å…¥: æ——${buildings.qi.length} å ¡${buildings.bao.length} å‘${buildings.keng.length} çŸ¿${buildings.kuang.length}`);
                    
                } catch (err) {
                    showValidationMessage('å¯¼å…¥å¤±è´¥: JSONæ ¼å¼é”™è¯¯');
                    console.error('Import error:', err);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // æ¸…ç©ºï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
        }
        
        // ========== ä¿å­˜ä¸ºå›¾ç‰‡ ==========
        function saveAsImage() {
            // åˆ›å»ºä¸´æ—¶canvasæ¥ç»˜åˆ¶å¯¼å‡ºç”¨å›¾ç‰‡
            const tempCanvas = document.createElement('canvas');
            const scale = 2; // 2å€æ¸…æ™°åº¦
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            const tempCtx = tempCanvas.getContext('2d');
            
            // ç¼©æ”¾ä»¥è·å¾—æ›´æ¸…æ™°çš„å›¾ç‰‡
            tempCtx.scale(scale, scale);
            
            // å¤åˆ¶å½“å‰canvaså†…å®¹
            tempCtx.fillStyle = '#F0F8FF';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);
            tempCtx.drawImage(canvas, 0, 0);
            
            // æ·»åŠ ç‰ˆæƒæ°´å°ï¼ˆå¦‚æœæœªå»é™¤ï¼‰
            if (!watermarkRemoved) {
                tempCtx.globalAlpha = 0.3;
                tempCtx.font = 'bold 24px Arial';
                tempCtx.fillStyle = '#fff';
                tempCtx.textAlign = 'right';
                tempCtx.textBaseline = 'bottom';
                tempCtx.fillText('Â© 2607å…¨æ°‘ä»£è¡¨å¤§ä¼š', canvas.width - 20, canvas.height - 20);
            }
            
            // å¯¼å‡ºä¸ºå›¾ç‰‡
            const link = document.createElement('a');
            link.download = 'layout-' + new Date().toISOString().slice(0,10) + '.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
            
            showValidationMessage('å·²ä¿å­˜å›¾ç‰‡');
        }
        
        // ========== åç§°åˆ†é…åŠŸèƒ½ ==========
        let currentModalAlliance = 0;
        const namesByAlliance = { 0: '', 1: '', 2: '', 3: '', 4: '', 5: '' };
        
        function openNameMatcher() {
            document.getElementById('name-modal').classList.add('show');
            switchModalTab(currentModalAlliance);
            updateNamePreview();
        }
        
        function closeNameMatcher() {
            document.getElementById('name-modal').classList.remove('show');
        }
        
        function switchModalTab(allianceId) {
            // ä¿å­˜å½“å‰è¾“å…¥
            namesByAlliance[currentModalAlliance] = document.getElementById('name-input').value;
            
            // åˆ‡æ¢æ ‡ç­¾
            currentModalAlliance = allianceId;
            document.querySelectorAll('.modal-tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === allianceId);
            });
            
            // åŠ è½½å¯¹åº”è”ç›Ÿçš„è¾“å…¥
            document.getElementById('name-input').value = namesByAlliance[allianceId] || '';
            updateNamePreview();
        }
        
        function updateNamePreview() {
            const previewDiv = document.getElementById('name-preview');
            const input = document.getElementById('name-input').value;
            const names = input.split(/[\s\n]+/).filter(n => n.trim());
            
            // è·å–å½“å‰è”ç›Ÿçš„å ¡åˆ—è¡¨ï¼ˆæŒ‰åºå·æ’åºï¼‰
            const baosOfAlliance = buildings.bao
                .filter(b => b.alliance === currentModalAlliance && b.index)
                .sort((a, b) => a.index - b.index);
            
            if (baosOfAlliance.length === 0) {
                previewDiv.innerHTML = '<div style="color:#888;padding:8px;">å½“å‰è”ç›Ÿæ²¡æœ‰æ¿€æ´»çš„å ¡</div>';
                return;
            }
            
            let html = '';
            const maxShow = Math.min(10, Math.max(names.length, baosOfAlliance.length));
            
            for (let i = 0; i < maxShow; i++) {
                const bao = baosOfAlliance[i];
                const name = names[i] || '';
                const indexDisplay = bao ? bao.index : (i + 1);
                const nameDisplay = name || (bao ? (bao.name || '(æœªåˆ†é…)') : '(æ— å ¡)');
                const color = name ? '#00d4ff' : '#666';
                
                html += `<div class="modal-preview-item">
                    <span class="modal-preview-num">${indexDisplay}å·</span>
                    <span class="modal-preview-name" style="color:${color}">${nameDisplay}</span>
                </div>`;
            }
            
            if (names.length > baosOfAlliance.length) {
                html += `<div style="color:#ff6b6b;font-size:10px;padding:4px;">âš ï¸ åç§°æ•°(${names.length})å¤šäºå ¡æ•°(${baosOfAlliance.length})</div>`;
            } else if (baosOfAlliance.length > maxShow) {
                html += `<div style="color:#888;font-size:10px;padding:4px;">... è¿˜æœ‰ ${baosOfAlliance.length - maxShow} ä¸ªå ¡</div>`;
            }
            
            previewDiv.innerHTML = html;
        }
        
        function applyNames() {
            // ä¿å­˜å½“å‰è¾“å…¥
            namesByAlliance[currentModalAlliance] = document.getElementById('name-input').value;
            
            let totalAssigned = 0;
            
            // ä¸ºæ¯ä¸ªè”ç›Ÿåˆ†é…åç§°
            for (let allianceId = 0; allianceId < 6; allianceId++) {
                const names = (namesByAlliance[allianceId] || '').split(/[\s\n]+/).filter(n => n.trim());
                
                // è·å–è¯¥è”ç›Ÿçš„å ¡åˆ—è¡¨ï¼ˆæŒ‰åºå·æ’åºï¼‰
                const baosOfAlliance = buildings.bao
                    .filter(b => b.alliance === allianceId && b.index)
                    .sort((a, b) => a.index - b.index);
                
                // åˆ†é…åç§°
                baosOfAlliance.forEach((bao, i) => {
                    if (i < names.length) {
                        bao.name = names[i];
                        totalAssigned++;
                    }
                });
            }
            
            closeNameMatcher();
            render();
            showValidationMessage(`å·²åˆ†é… ${totalAssigned} ä¸ªåç§°`);
        }
        
        function clearBaoNames() {
            // æ¸…é™¤å½“å‰è”ç›Ÿçš„åç§°
            buildings.bao.forEach(b => {
                if (b.alliance === currentModalAlliance) {
                    b.name = '';
                }
            });
            document.getElementById('name-input').value = '';
            namesByAlliance[currentModalAlliance] = '';
            updateNamePreview();
            render();
            showValidationMessage(`å·²æ¸…é™¤${ALLIANCES[currentModalAlliance].name}å ¡çš„åç§°`);
        }
        
        // ç›‘å¬è¾“å…¥å˜åŒ–æ›´æ–°é¢„è§ˆ
        document.addEventListener('DOMContentLoaded', function() {
            const nameInput = document.getElementById('name-input');
            if (nameInput) {
                nameInput.addEventListener('input', updateNamePreview);
            }
        });
        
        // init() æ”¹ä¸ºåœ¨ç™»å½•æˆåŠŸåç”± initApp() è°ƒç”¨
    </script>
</body>
</html>
